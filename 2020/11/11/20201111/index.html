<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="读书，睡觉，发呆" />
   
  <meta name="description" content="0" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    区块链学习 |  Yozo&#39;s Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="Yozo's Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      <canvas class="fireworks"></canvas>
      <style>
        .fireworks {
          position: fixed;
          left: 0;
          top: 0;
          z-index: 99999;
          pointer-events: none;
        }
      </style>
      
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-20201111"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  区块链学习
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/11/11/20201111/" class="article-date">
  <time datetime="2020-11-11T15:00:27.000Z" itemprop="datePublished">2020-11-11</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">5.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">21 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><hr>
<p>这篇博客主要总结一下区块链学习中的一些有趣的东西。</p>
<h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><hr>
<p>按照老师的要求以及助教给的一些问题的解决方案。把python从3.8装回3.7再装回3.6，好像都没什么用。在pycharm运行代码总是说缺少依赖，然而明明已经装过了，点击它给的解决方案安装依赖，然后安装失败。于是我灵机一动，把之前装过的都卸掉了，再点那个安装，还是失败，于是我打开里面的虚拟终端通过命令行来安装。终于不提示缺少依赖。然而运行的时候，提示我的python-bitcoinlib库有问题，点进去查看源码依然毫无头绪。然后打开了虚拟机里的Ubuntu，安装依赖后可以跑代码。于是我的环境终于有了。</p>
<h1 id="领取测试币"><a href="#领取测试币" class="headerlink" title="领取测试币"></a>领取测试币</h1><hr>
<p> 进到<a target="_blank" rel="noopener" href="https://coinfaucet.eu/en/btctestnet/">比特币测试网络</a>领取比特币，在找完公交车或者自行车以及斑马线之后总是卡住不同，于是挂vpn再访问终于施舍给了我点币子。</p>
<h1 id="比特币脚本（暂时了解的）"><a href="#比特币脚本（暂时了解的）" class="headerlink" title="比特币脚本（暂时了解的）"></a>比特币脚本（暂时了解的）</h1><hr>
<p>比特币脚本语言是一种基于栈的脚本语言（每个命令只执行一次），不是图灵完备的。比特币脚本包含两个部分，解锁脚本+锁定脚本，连在一起才是完整的，运行正确之后在栈中返回一个Ture。</p>
<h2 id="公钥支付-P2PK-（Pay-to-Publish-Key）"><a href="#公钥支付-P2PK-（Pay-to-Publish-Key）" class="headerlink" title="公钥支付 P2PK （Pay to Publish Key）"></a>公钥支付 P2PK （Pay to Publish Key）</h2><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;pubkey&gt;         #公钥</span><br><span class="line">OP_CKECKSIG      #验证签名的脚本语言</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sig&gt;            #签名</span><br></pre></td></tr></table></figure>
<p><code>OP_CKECKSIG</code>的部分函数定义，大致看起来就是利用<code>pubkey</code>生成一个数字签名，再与输入的签名比较，最后如果是<code>ok</code>就会在栈里留下一个<code>Ture</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def _CheckSig(sig, pubkey, script, txTo, inIdx, err_raiser):</span><br><span class="line">    key &#x3D; bitcoin.core.key.CECKey()</span><br><span class="line">    key.set_pubkey(pubkey)</span><br><span class="line"></span><br><span class="line">    if len(sig) &#x3D;&#x3D; 0:</span><br><span class="line">        return False</span><br><span class="line">    hashtype &#x3D; _bord(sig[-1])</span><br><span class="line">    sig &#x3D; sig[:-1]</span><br><span class="line">    (h, err) &#x3D; RawSignatureHash(script, txTo, inIdx, hashtype)</span><br><span class="line">    return key.verify(h, sig)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">elif sop &#x3D;&#x3D; OP_CHECKSIG or sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                vchPubKey &#x3D; stack[-1]</span><br><span class="line">                vchSig &#x3D; stack[-2]</span><br><span class="line">                tmpScript &#x3D; CScript(scriptIn[pbegincodehash:])</span><br><span class="line">                tmpScript &#x3D; FindAndDelete(tmpScript, CScript([vchSig]))</span><br><span class="line"></span><br><span class="line">                ok &#x3D; _CheckSig(vchSig, vchPubKey, tmpScript, txTo, inIdx,</span><br><span class="line">                               err_raiser)</span><br><span class="line">                if not ok and sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                    err_raiser(VerifyOpFailedError, sop)</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">                    if ok:</span><br><span class="line">                        if sop !&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                            stack.append(b&quot;\x01&quot;)</span><br><span class="line">                    else:</span><br><span class="line">                        # FIXME: this is incorrect, but not caught by existing</span><br><span class="line">                        # test cases</span><br><span class="line">                        stack.append(b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>
<p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">----------</span><br><span class="line">&lt;pubkey&gt;         </span><br><span class="line">OP_CKECKSIG </span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NULL|初始状态，栈为空</span><br><span class="line">&lt;Sig&gt;|&lt;Sig&gt;压栈</span><br><span class="line">&lt;Sig&gt;&lt;pubkey&gt;|&lt;pubkey&gt;压栈</span><br><span class="line">Ture|执行OP_CHECKSIG,成功会把前两个东西pop掉，压入一个Ture</span><br></pre></td></tr></table></figure>
<h2 id="P2PKH（Pay-To-Public-Key-Hash）"><a href="#P2PKH（Pay-To-Public-Key-Hash）" class="headerlink" title="P2PKH（Pay To Public Key Hash）"></a>P2PKH（Pay To Public Key Hash）</h2><p>刚开始不知道公钥哈希值是什么，原来就是我们的地址。私钥通过SHA256得到公钥，公钥经过RIPEMD160得到公钥哈希，公钥哈希经过Base58编码就是地址，某种意义上，地址就是公钥哈希</p>
<hr>
<p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br><span class="line">----------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY   #检验两个值是否相等，不会返回值，只会删去栈顶两个元素</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NULL	| 初始状态栈为空</span><br><span class="line">&lt;sig&gt;	| sig压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| pubKey压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKey&gt;	| OP_DUP复制栈顶元素并将其压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;	| OP_HASH160计算公钥哈希值并用其替换栈顶</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;&lt;pubKeyHash?&gt;	| 已知的address压栈，即不知道</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| 比较address和pubKeyHash，相等后抛弃栈顶开始的两位，不相等就终止</span><br><span class="line">true	| 用CHECKSIG验证签名有效，有效则true，无效则false</span><br></pre></td></tr></table></figure>
<h2 id="多重签名P2MS-Multiple-Signatures"><a href="#多重签名P2MS-Multiple-Signatures" class="headerlink" title="多重签名P2MS(Multiple Signatures)"></a>多重签名P2MS(Multiple Signatures)</h2><hr>
<p>对于一个M-N的交易（M是需要认证的人数，N是总人数，即只要N中M个人的签名），锁定脚本为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OP_0            # OP_CHECKMULTISIG的一个bug，下面会解释</span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;</span><br><span class="line">----------</span><br><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NULL |初始状态，栈为空</span><br><span class="line">0    |OP_0将0压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;|M个签名入栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M|OP_M把M压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M&lt;PublicKey 1&gt;&lt;PublicKey 2&gt;···&lt;PublicKey N&gt;  |N个PublicKey入栈</span><br><span class="line">True |OP_CHECKMULTISIG进行验证，成功则返回一个ture</span><br></pre></td></tr></table></figure>
<p>OP_0是OP_CHECKMULTISIG的一个bug，不过由于历史遗留问题，debug成本过高，所以就遗留下来了，没什么具体含义，可以当成一个小彩蛋。OP_CHECKMULTISIG所做的具体操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">弹出一个N，得到公钥数量</span><br><span class="line">弹出N个公钥的值</span><br><span class="line">弹出一个M，得到签名数量</span><br><span class="line">弹出M个签名</span><br><span class="line">得到了所有数据，计算脚本是否有效</span><br></pre></td></tr></table></figure>
<p>在弹出M个签名之后，会再pop一次，如果没有OP_0，存在，这时候栈已经空了，pop会出错，脚本没法运行，OP_0就是为了这个bug而生的，弹出的OP_0不会对脚本运行结果产生影响，只是让它能够运行，所以压入什么数应该都可以</p>
<h2 id="脚本哈希支付P2SH（Pay-to-Script-Hash）"><a href="#脚本哈希支付P2SH（Pay-to-Script-Hash）" class="headerlink" title="脚本哈希支付P2SH（Pay to Script Hash）"></a>脚本哈希支付P2SH（Pay to Script Hash）</h2><p>一开始以为这个和Multiple Signatures是一样的东西，后来看了很多博客才知道是可以通过这种方法实现P2MS,P2SH是2012年提出的，个人理解这个脚本是为了防止Script过于长而导致交易失败，通过HASH160得到脚本的哈希值，这样就能解决长度问题</p>
<hr>
<p>P2SH中的脚本包括三部分，赎回脚本(redeem Script)、锁定脚本（locking Script）、解锁脚本（unlocking Script）</p>
<hr>
<p>赎回脚本(redeem Script)类似于之前脚本里的锁定脚本（locking Script）内容是一致的<br>锁定脚本（locking Script）形式是固定的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本（unlocking Script）与赎回脚本相关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">&lt;Sig&gt;</span><br><span class="line">···       #需要的签名以及其他内容</span><br><span class="line">&lt;serialized redeem Script&gt; #序列化的赎回脚本，作为数据而不作为脚本语言压栈</span><br></pre></td></tr></table></figure>
<p>脚本的执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先就是解锁的脚本压栈</span><br><span class="line">此时栈顶就是&lt;serialized redeem Script&gt;</span><br><span class="line">然后锁定脚本依次压栈</span><br><span class="line">先得到赎回栈顶的哈希值</span><br><span class="line">再与锁定脚本中的哈希值对比两者不匹配验证就失败</span><br><span class="line">成功则序列化脚本会被反序列化再与栈内的剩余内容（也就是解锁脚本中剩下的所有&lt;Sig&gt;或者其他内容）构成完整的脚本</span><br></pre></td></tr></table></figure>

<p>下面以实现P2PKH与P2MS两种脚本为例写两个P2SH脚本</p>
<hr>
<h3 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   </span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="P2MS"><a href="#P2MS" class="headerlink" title="P2MS"></a>P2MS</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          </span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;  </span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h2 id="作业中的unknown脚本（P2PK-P2MS）"><a href="#作业中的unknown脚本（P2PK-P2MS）" class="headerlink" title="作业中的unknown脚本（P2PK+P2MS）"></a>作业中的unknown脚本（P2PK+P2MS）</h2><h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><ul>
<li>生成一个涉及四方的多签名交易，这样交易可以由第一方（银行）与另外三方（客户）中的任何一方（客户）共同赎回，而不仅仅只是客户或银行。对于这个问题，你可以假设是银行的角色，这样银行的私钥就是你的私钥，而银行的公钥就是你的公钥。使用keygen.py生成客户密钥并将它们粘贴到ex2a.py中。</li>
<li>赎回事务并确保scriptPubKey尽可能小。可以使用任何合法的签名组合来赎回交易，但要确保所有组合都有效</li>
</ul>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该交易中一共有四位参与者，银行与三位客户，需要银行与其他任何一个用户的签名才能赎回交易，如果只用多重签名，那么不需要银行的签名也能赎回，所以我们要把实验分两步，一步是验证银行签名，另外一步是验证客户签名。所以可以用P2PK+P2MS构成的脚本</p>
<h3 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h3><p>其实上述两个步骤没有先后顺序，银行和客户身份先验证后验证都无所谓，反正逃不过验证，只不过用的脚本会不一样</p>
<h4 id="先银行后客户"><a href="#先银行后客户" class="headerlink" title="先银行后客户"></a>先银行后客户</h4><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;pubkey bank&gt;     #银行公钥</span><br><span class="line">OP_CHECKSIGVERIFY #使用OP_CHECKSIGVERIFY而不用OP_CHECKSIG是因为它不会有在栈里压数剧，后面脚本执行不会出错</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        #三个客户的公钥</span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OP_0             </span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt;       #注意顺序，因为先验证银行，所以银行的pubkey要在栈顶</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt; </span><br><span class="line">----------</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIGVERIFY</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NULL	| 起始状态</span><br><span class="line">0           | OP_0压栈</span><br><span class="line">0&lt;sig cust&gt;	| &lt;sig cust&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;	| &lt;sig bank&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;&lt;pubkey bank&gt;	| pubkey bank压栈</span><br><span class="line">0&lt;sig cust&gt;	| CHECKSIGVERIFY验证&lt;sig bank&gt;和&lt;pubkey bank&gt;是否匹配并将它们pop掉，匹配则继续，不匹配直接就验证不成功</span><br><span class="line">0&lt;sig cust&gt; 1	| OP_1压栈，确定需要检查的参数</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt;	| 3个pubkey压栈</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt; 3  | OP_3确定3个参数作为检查的范围</span><br><span class="line">true	| OP_CHECKMULTISIG检查多重签名，成功返回一个ture，否则验证失败</span><br></pre></td></tr></table></figure>
<h4 id="先客户后银行"><a href="#先客户后银行" class="headerlink" title="先客户后银行"></a>先客户后银行</h4><p>原理相同只给出完整脚本（注意脚本指令变了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;sig bank&gt; </span><br><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">----------</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIGVERIFY</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>

<h1 id="自定义的脚本（解方程？？？）"><a href="#自定义的脚本（解方程？？？）" class="headerlink" title="自定义的脚本（解方程？？？）"></a>自定义的脚本（解方程？？？）</h1><h2 id="作业要求-1"><a href="#作业要求-1" class="headerlink" title="作业要求"></a>作业要求</h2><p>(a）生成可通过以下两个线性方程组的解x，y）赎回的交易:<br>x+y= (StudentID of First Half）和x-y= (StudentID of Second Half)<br>[为确保存在整数解，请更改右侧两个数字的最后一位，使数字都是偶数或都是奇数]。<br>(b）赎回交易。赎回脚本应尽可能小。也就是说，一个有效的<code>scriptSig</code>应该是简单地将两个整数x和y发送到堆栈中。确保在<code>scriptPubKey</code>中使用了<code>OP_ADD</code>和<code>OP_SUB</code>。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这个作业看起来就像是让你解个方程，然后验证一下你解的方乘对不对。（不过要是真的用这样脚本交易比特币那自己币子不是别人想用就随便用了嘛ORZ）<br>已经说了解锁脚本就是x和y，那么首先压入栈里的就是x和y，那接下就要验证x和y是不是方乘的解。<br>首先先把xy复制一遍，因为需要验证两个方程得用两边，就用到了<code>OP_2DUP</code>，它的定义是这样的，所以能把栈顶两个元素赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_2DUP:</span><br><span class="line">check_args(2)</span><br><span class="line">v1 &#x3D; stack[-2]</span><br><span class="line">v2 &#x3D; stack[-1]</span><br><span class="line">stack.append(v1)</span><br><span class="line">stack.append(v2)</span><br></pre></td></tr></table></figure>
<p>然后就把x和y加起来，用<code>OP_ADD</code>脚本，它在执行的时候会把x和y<code>pop</code>掉然后再把结果<code>push</code>进栈里<br>接着拿这个<code>result</code>和原方程里的值比较是否一致，这里之所以使用的是<code>OP_EQUALVERIFY</code>，是因为它不会产生一个返回值，而使用<code>OP_EQUAL</code>会在栈里留下一个ture值没法处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUALVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack[-1]</span><br><span class="line">                v2 &#x3D; stack[-2]</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br></pre></td></tr></table></figure>
<p>然后差不多和前面一样的思路，先得到一个减的结果，然后和方程里的值比较，用<code>OP_EQUAL</code>验证，在栈里留下一个true值,这里可以看到并不是直接返回一个false或者true，而是返回的<code>\x01</code>或者<code> </code>，应该是和true或者false一样的功能，为空是false，不为空是ture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUAL:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack.pop()</span><br><span class="line">                v2 &#x3D; stack.pop()</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.append(b&quot;\x01&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    stack.append(b&quot;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="实现脚本"><a href="#实现脚本" class="headerlink" title="实现脚本"></a>实现脚本</h2><h3 id="锁定脚本"><a href="#锁定脚本" class="headerlink" title="锁定脚本"></a>锁定脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;X&gt; #解方程的得到的xy值</span><br><span class="line">&lt;y&gt;</span><br></pre></td></tr></table></figure>
<h3 id="脚本运行过程"><a href="#脚本运行过程" class="headerlink" title="脚本运行过程"></a>脚本运行过程</h3><p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;X&gt; </span><br><span class="line">&lt;y&gt;</span><br><span class="line">-----</span><br><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<p>运行过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NULL    #起始状态，栈内为空</span><br><span class="line">&lt;x&gt;     #x压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #y压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;x&gt;&lt;y&gt; #OP_2DUP复制栈顶及栈顶下一个元素并压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt; #OP_ADD弹出xy并且将xy相加的结果压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt;&lt;stuid first&gt; #学号前四位压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #OP_EQUALVERIFY验证两个内容是否相等，相等则将其弹出</span><br><span class="line">&lt;sub_result&gt; #OP_SUB弹出xy并且将xy相减的结果压栈</span><br><span class="line">&lt;sub_result&gt;&lt;stuid second&gt; #学号后三位压栈</span><br><span class="line">ture    #OP_EQUAL验证栈内的两个数值是否相等然后将true压栈</span><br></pre></td></tr></table></figure>
<h2 id="掉进去的坑"><a href="#掉进去的坑" class="headerlink" title="掉进去的坑"></a>掉进去的坑</h2><p>没有用<code>OP_EQUALVERIFY</code>和<code>OP_EQUAL</code>用了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code><br>翻看python-bitcoinlib的源码，一开始只看到了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUAL:</span><br><span class="line">   bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.append(bitcoin.core._bignum.bn2vch(bn))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUALVERIFY:</span><br><span class="line">        bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">        if not bn:</span><br><span class="line">            err_raiser(VerifyOpFailedError, opcode)</span><br><span class="line">        else:</span><br><span class="line">            # No exception, so time to pop the stack</span><br><span class="line">            stack.pop()</span><br><span class="line">            stack.pop()</span><br><span class="line">            return</span><br></pre></td></tr></table></figure>
<p>看似是没有什么大问题的，不过<code>OP_NUMEQUAL</code>里并没有直接把<code>bn</code>压栈，反而是调用了一个函数<code>bitcoin.core._bignum.bn2vch</code>，里面有<code>bignum</code>而且<code>bn</code>类型为<code>long</code>，调用的函数可能对bn做了处理导致最后没有办法得到ture之类的，那个函数也看了下定义之类的没有看得很清楚，因为函数里又调了别的函数。不过肯定是那个函数的锅。（浪费了我一份币子，还好当时分了十份）</p>
<h1 id="跨链原子交易"><a href="#跨链原子交易" class="headerlink" title="跨链原子交易"></a>跨链原子交易</h1><h2 id="实验介绍与要求"><a href="#实验介绍与要求" class="headerlink" title="实验介绍与要求"></a>实验介绍与要求</h2><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><blockquote>
<p>在本次任务中，你需要创建一个称为跨链原子交换的交易，允许两个实体在不同的区块链上安全地交换加密货币的所有权。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在这项作业中，你需要实现Alice和Bob两方之间跨链原子交换代码的关键部分。Alice在BTCTestnet3上有比特币，这是project1使用的标准比特币测试网。Bob在BCY Testnet 上拥有比特币，BCY Testnet是Blockcypher 的比特币测试网，由Blockcypher独家挖矿和维护。他们希望安全地交换各自coin的所有权，这是一个简单交易无法完成的事情，因为它们位于不同的区块链上。这里的想法是围绕一个只有一方(Alice）知道的秘密x建立交易。在这些事务中，只有H(x)将被发布，而x为秘密。交易将以这样的方式建立，一旦x被揭露，双方都可以赎回对方发送的硬币。如果x永远不会被揭露，双方将能够安全地取回他们的原始硬币，而不需要另一方的帮助。这种方法也适用于其他加密货币。</p>
</blockquote>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><blockquote>
<p>运行课程代码pip install -r requirements.txt安装所需的依赖项。确保使用的是python3。</p>
</blockquote>
<p>这个之前已经已经接安装过了这次就不用再做了</p>
<h3 id="创建BTC密钥并领取测试币"><a href="#创建BTC密钥并领取测试币" class="headerlink" title="创建BTC密钥并领取测试币"></a>创建BTC密钥并领取测试币</h3><blockquote>
<p>(a）为Alice和 Bob 创建BTC testnet密钥。你可以用keygen.py 生成密钥，把它填入keys.py中合适的地方。<br>(b）在 Project1中相同的<a target="_blank" rel="noopener" href="https://coinfaucet.eu/en/btc-testnet/">coinfaucet</a> 上，为Alice的BTC地址领取测试币。</p>
</blockquote>
<p>这个也是之前做过的了，慢慢找公交车人行道自行车吧，Good Luck！</p>
<h3 id="注册BCY创建密钥领取测试币"><a href="#注册BCY创建密钥领取测试币" class="headerlink" title="注册BCY创建密钥领取测试币"></a>注册BCY创建密钥领取测试币</h3><blockquote>
</blockquote>
<p>(a）在Blockcypher注册帐户以获取API token: <a target="_blank" rel="noopener" href="https://accounts.blockcypher.com/%E3%80%82">https://accounts.blockcypher.com/。</a><br>(b）为Alice和Bob创建BCY testnet密钥并填入keys.py.<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl-X POST https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;addrs?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure><br>(c）在Blockcypher 测试网（BCY）上为Bob的BCY地址领取测试币。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl-d&#39;&#123;&quot;address&quot;:&quot;BOB_BCY_ADDRESs&quot;, &quot;amount&quot;: 1000000&#125;&#39; https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;faucet?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure>

<p>这个相对于BTC领币过程也太“流云行水”了，curl用前需要装一下，终端输入<code>sudo apt-get install curl</code>就能装了。然后在终端里输入题目里给的命令就好</p>
<h3 id="划分测试币"><a href="#划分测试币" class="headerlink" title="划分测试币"></a>划分测试币</h3><blockquote>
<p>使用split_test_coins.py（填写文件中的相关字段）划分领取的币。</p>
</blockquote>
<p>把对应的地方填上就行，不过需要注意，划分BCY测试币的时候，注意改一下调用的函数（参考keys.py中的样式），以及network的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#BTC：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;)</span><br><span class="line">#BCY：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret.from_secret_bytes(x(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完善swap-py"><a href="#完善swap-py" class="headerlink" title="完善swap.py"></a>完善swap.py</h3><blockquote>
<p>填写swap.py.</p>
</blockquote>
<p>按照提示一步一步写</p>
<h3 id="完善swap-scripts-py"><a href="#完善swap-scripts-py" class="headerlink" title="完善swap_scripts.py"></a>完善swap_scripts.py</h3><p>这部分是本次实验核心部分</p>
<h3 id="要求及源码"><a href="#要求及源码" class="headerlink" title="要求及源码"></a>要求及源码</h3><blockquote>
<p>A.考虑创建跨链原子交换所需事务所需的ScriptPubKey。此交易必须可由接收者赎回（如果他们有一个与Hash(x）对应的秘密x)，或者可以用发送者和接收者的两个签名赎回。完善swap_scripts.py 中的脚本coinExchangeScript。<br>B.完善脚本:<br>(a）在接收者知道秘密x的情况下，编写赎回交易所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig1.<br>(b）在发送方和接收方都签署事务的情况下，编写赎回事务所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig2.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScript</span>(<span class="params">public_key_sender, public_key_recipient, hash_of_secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig1</span>(<span class="params">sig_recipient, secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig2</span>(<span class="params">sig_sender, sig_recipient</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据题目要求，我们的锁定脚本应该能够用两个不同解锁脚本解锁所以需要用到<code>OP_IF</code>、<code>OP_ELSE</code> 、<code>OP_ENDIF</code>等脚本语言来处理不同解锁脚本。</p>
<ul>
<li>对于用秘密X及接收者签名赎回的脚本，我们只需要先验证X的哈希值是否正确，然后再用P2PK脚本验证接收者签名</li>
<li>对于用两个签名赎回的脚本，我们只需要用P2MS就可以实现</li>
<li>对于知道秘密X的解锁脚本，我们只需将签名与秘密依次压栈</li>
<li>对于两个签名的解锁脚本，把两个签名压栈即可，不过需要注意先OP_0</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="解锁脚本1："><a href="#解锁脚本1：" class="headerlink" title="解锁脚本1："></a>解锁脚本1：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sig_recipient&gt;,&lt;seret&gt;</span><br></pre></td></tr></table></figure>

<h5 id="解锁脚本2："><a href="#解锁脚本2：" class="headerlink" title="解锁脚本2："></a>解锁脚本2：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP_0 &lt;sig_sender&gt; ,&lt;sig_recipient&gt;</span><br></pre></td></tr></table></figure>
<h5 id="锁定脚本："><a href="#锁定脚本：" class="headerlink" title="锁定脚本："></a>锁定脚本：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OP_DEPTH, 2, OP_EQUAL, </span><br><span class="line">OP_IF, </span><br><span class="line">OP_HASH160, hash_of_secret, OP_EQUALVERIFY, public_key_recipient, OP_CHECKSIG, OP_ELSE,</span><br><span class="line">2, public_key_sender, public_key_recipient, 2, OP_CHECKMULTISIG,</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>可以把锁定脚本看作三部分</p>
<ul>
<li>第一部分是用来检验是哪个解锁脚本从而执行相应的检验<br>我们可以发现两个脚本长度不同，于是可以利用这一点来分辨是哪个脚本，利用<code>OP_DEPTH</code>得到栈大小可以实现<br>或者是在第二个解锁脚本中存在一个OP_O，于是可以用<code>OP_PICK</code>将栈底复制到栈顶，然后与<code>OP_0</code>对比，这样也可以</li>
<li>第二部分是执行<code>OP_IF</code>后的分支，验证秘密X与接收者签名</li>
<li>第三部分是执行<code>OP_ELSE</code>后的分至，验证两个签名</li>
</ul>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NULL							|初始状态栈为空</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |&lt;sig_recipient&gt;,&lt;seret&gt;依次入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;	   |OP_DEPTH得到栈大小为2，并将2压栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;&lt;2&gt;	|2入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;Ture&gt;	|OP_EQUAL比较栈顶两个的值并将其pop，将Ture压栈，这里不能用OP_EQUALVERIFY，因为我们需要在栈里压入一个标志来确定执行OP_IF还是OP_ELSE</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |OP_IF检测栈顶值并将其pop，进入if分支</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;|得到secret的哈希值</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;&lt;hash_of_secret&gt;|&lt;hash_of_secret&gt;压栈</span><br><span class="line">&lt;sig_recipient&gt;		   	  |OP_EQUALVERIFY检测两个哈希值是否相等并将其pop</span><br><span class="line">&lt;sig_recipient&gt;&lt;public_key_recipient&gt;|public_key_recipient入栈</span><br><span class="line">&lt;Ture&gt;						  |OP_CHECKSIG</span><br><span class="line">&lt;Ture&gt;						  |最后几步其实就是简单的P2PK，最后的OP_ENDIF一定要加			</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NULL 							           |初始状态栈为空</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;       |&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;依次入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;    |OP_DEPTH得到栈大小为，并将3压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;&lt;2&gt; |2入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;False&gt;|OP_EQUAL比较栈顶两个的值并将其pop，将False压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;	   |OP_IF检测栈顶值，为false，不执行if分至，有OP_ELSE，跳转到else</span><br><span class="line"></span><br><span class="line">#略</span><br><span class="line"></span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2020/11/11/20201111/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%8B%8F%E6%98%8Eyyds/" rel="tag">苏明yyds</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/04/26/Bugku-Web25/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Bugku Web25
          
        </div>
      </a>
    
    
      <a href="/2020/11/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Hexo博客搭建（Windows）</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "Eh3N1lkQleVJgTkzppLn9zB5-gzGzoHsz",
    app_key: "ncBQ2Ug9wmUYRzYuMCovmmm9",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "有事没事说两句~",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020-2021
        <i class="ri-heart-fill heart_icon"></i> Yozo
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
	<!-- 运行天数 -->
    <ul>
        <li><span id="runtime_span"></span></li>
		<script type="text/javascript">            
    function show_runtime() {
        window.setTimeout("show_runtime()", 1000);
        X = new Date("11/04/2020 22:22:22");
        Y = new Date();
        T = (Y.getTime() - X.getTime());
        M = 24 * 60 * 60 * 1000;
        a = T / M;
        A = Math.floor(a);
        b = (a - A) * 24;
        B = Math.floor(b);
        c = (b - B) * 60;
        C = Math.floor((b - B) * 60);
        D = Math.floor((c - C) * 60);
        runtime_span.innerHTML = "小破站在各种崩坏中坚持了: " + A + "天" + B + "小时" + C + "分" + D + "秒"
    }
    show_runtime();
</script>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/tou.jpg" alt="Yozo&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/musiclist">音乐</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>肥宅快乐水走起~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/11/05/RJkjgW2eFd8i4HD.png">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://i.loli.net/2020/11/05/8GSwuPaRFxCmn4b.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script>

<script src="/js/clickBoom1.js"></script>


<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"log":false});</script></body>

</html>