<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>区块链学习</title>
    <url>/2020/11/11/20201111/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><hr>
<p>这篇博客主要总结一下区块链学习中的一些有趣的东西。</p>
<h1 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h1><hr>
<p>按照老师的要求以及助教给的一些问题的解决方案。把python从3.8装回3.7再装回3.6，好像都没什么用。在pycharm运行代码总是说缺少依赖，然而明明已经装过了，点击它给的解决方案安装依赖，然后安装失败。于是我灵机一动，把之前装过的都卸掉了，再点那个安装，还是失败，于是我打开里面的虚拟终端通过命令行来安装。终于不提示缺少依赖。然而运行的时候，提示我的python-bitcoinlib库有问题，点进去查看源码依然毫无头绪。然后打开了虚拟机里的Ubuntu，安装依赖后可以跑代码。于是我的环境终于有了。</p>
<h1 id="领取测试币"><a href="#领取测试币" class="headerlink" title="领取测试币"></a>领取测试币</h1><hr>
<p> 进到<a href="https://coinfaucet.eu/en/btctestnet/">比特币测试网络</a>领取比特币，在找完公交车或者自行车以及斑马线之后总是卡住不同，于是挂vpn再访问终于施舍给了我点币子。</p>
<h1 id="比特币脚本（暂时了解的）"><a href="#比特币脚本（暂时了解的）" class="headerlink" title="比特币脚本（暂时了解的）"></a>比特币脚本（暂时了解的）</h1><hr>
<p>比特币脚本语言是一种基于栈的脚本语言（每个命令只执行一次），不是图灵完备的。比特币脚本包含两个部分，解锁脚本+锁定脚本，连在一起才是完整的，运行正确之后在栈中返回一个Ture。</p>
<h2 id="公钥支付-P2PK-（Pay-to-Publish-Key）"><a href="#公钥支付-P2PK-（Pay-to-Publish-Key）" class="headerlink" title="公钥支付 P2PK （Pay to Publish Key）"></a>公钥支付 P2PK （Pay to Publish Key）</h2><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pubkey&gt;         #公钥</span><br><span class="line">OP_CKECKSIG      #验证签名的脚本语言</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;            #签名</span><br></pre></td></tr></table></figure>
<p><code>OP_CKECKSIG</code>的部分函数定义，大致看起来就是利用<code>pubkey</code>生成一个数字签名，再与输入的签名比较，最后如果是<code>ok</code>就会在栈里留下一个<code>Ture</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _CheckSig(sig, pubkey, script, txTo, inIdx, err_raiser):</span><br><span class="line">    key &#x3D; bitcoin.core.key.CECKey()</span><br><span class="line">    key.set_pubkey(pubkey)</span><br><span class="line"></span><br><span class="line">    if len(sig) &#x3D;&#x3D; 0:</span><br><span class="line">        return False</span><br><span class="line">    hashtype &#x3D; _bord(sig[-1])</span><br><span class="line">    sig &#x3D; sig[:-1]</span><br><span class="line">    (h, err) &#x3D; RawSignatureHash(script, txTo, inIdx, hashtype)</span><br><span class="line">    return key.verify(h, sig)</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">elif sop &#x3D;&#x3D; OP_CHECKSIG or sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                vchPubKey &#x3D; stack[-1]</span><br><span class="line">                vchSig &#x3D; stack[-2]</span><br><span class="line">                tmpScript &#x3D; CScript(scriptIn[pbegincodehash:])</span><br><span class="line">                tmpScript &#x3D; FindAndDelete(tmpScript, CScript([vchSig]))</span><br><span class="line"></span><br><span class="line">                ok &#x3D; _CheckSig(vchSig, vchPubKey, tmpScript, txTo, inIdx,</span><br><span class="line">                               err_raiser)</span><br><span class="line">                if not ok and sop &#x3D;&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                    err_raiser(VerifyOpFailedError, sop)</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">                    if ok:</span><br><span class="line">                        if sop !&#x3D; OP_CHECKSIGVERIFY:</span><br><span class="line">                            stack.append(b&quot;\x01&quot;)</span><br><span class="line">                    else:</span><br><span class="line">                        # FIXME: this is incorrect, but not caught by existing</span><br><span class="line">                        # test cases</span><br><span class="line">                        stack.append(b&quot;\x00&quot;)</span><br></pre></td></tr></table></figure>
<p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">----------</span><br><span class="line">&lt;pubkey&gt;         </span><br><span class="line">OP_CKECKSIG </span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL|初始状态，栈为空</span><br><span class="line">&lt;Sig&gt;|&lt;Sig&gt;压栈</span><br><span class="line">&lt;Sig&gt;&lt;pubkey&gt;|&lt;pubkey&gt;压栈</span><br><span class="line">Ture|执行OP_CHECKSIG,成功会把前两个东西pop掉，压入一个Ture</span><br></pre></td></tr></table></figure>
<h2 id="P2PKH（Pay-To-Public-Key-Hash）"><a href="#P2PKH（Pay-To-Public-Key-Hash）" class="headerlink" title="P2PKH（Pay To Public Key Hash）"></a>P2PKH（Pay To Public Key Hash）</h2><p>刚开始不知道公钥哈希值是什么，原来就是我们的地址。私钥通过SHA256得到公钥，公钥经过RIPEMD160得到公钥哈希，公钥哈希经过Base58编码就是地址，某种意义上，地址就是公钥哈希</p>
<hr>
<p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig&gt;</span><br><span class="line">&lt;pubkey&gt;</span><br><span class="line">----------</span><br><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY   #检验两个值是否相等，不会返回值，只会删去栈顶两个元素</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL	| 初始状态栈为空</span><br><span class="line">&lt;sig&gt;	| sig压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| pubKey压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKey&gt;	| OP_DUP复制栈顶元素并将其压栈</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;	| OP_HASH160计算公钥哈希值并用其替换栈顶</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;&lt;pubKeyHash&gt;&lt;pubKeyHash?&gt;	| 已知的address压栈，即不知道</span><br><span class="line">&lt;sig&gt;&lt;pubKey&gt;	| 比较address和pubKeyHash，相等后抛弃栈顶开始的两位，不相等就终止</span><br><span class="line">true	| 用CHECKSIG验证签名有效，有效则true，无效则false</span><br></pre></td></tr></table></figure>
<h2 id="多重签名P2MS-Multiple-Signatures"><a href="#多重签名P2MS-Multiple-Signatures" class="headerlink" title="多重签名P2MS(Multiple Signatures)"></a>多重签名P2MS(Multiple Signatures)</h2><hr>
<p>对于一个M-N的交易（M是需要认证的人数，N是总人数，即只要N中M个人的签名），锁定脚本为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            # OP_CHECKMULTISIG的一个bug，下面会解释</span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;</span><br><span class="line">----------</span><br><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL |初始状态，栈为空</span><br><span class="line">0    |OP_0将0压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;|M个签名入栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M|OP_M把M压栈</span><br><span class="line">0&lt;Sig1&gt;&lt;Sig2&gt;···&lt;SigM&gt;M&lt;PublicKey 1&gt;&lt;PublicKey 2&gt;···&lt;PublicKey N&gt;  |N个PublicKey入栈</span><br><span class="line">True |OP_CHECKMULTISIG进行验证，成功则返回一个ture</span><br></pre></td></tr></table></figure>
<p>OP_0是OP_CHECKMULTISIG的一个bug，不过由于历史遗留问题，debug成本过高，所以就遗留下来了，没什么具体含义，可以当成一个小彩蛋。OP_CHECKMULTISIG所做的具体操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出一个N，得到公钥数量</span><br><span class="line">弹出N个公钥的值</span><br><span class="line">弹出一个M，得到签名数量</span><br><span class="line">弹出M个签名</span><br><span class="line">得到了所有数据，计算脚本是否有效</span><br></pre></td></tr></table></figure>
<p>在弹出M个签名之后，会再pop一次，如果没有OP_0，存在，这时候栈已经空了，pop会出错，脚本没法运行，OP_0就是为了这个bug而生的，弹出的OP_0不会对脚本运行结果产生影响，只是让它能够运行，所以压入什么数应该都可以</p>
<h2 id="脚本哈希支付P2SH（Pay-to-Script-Hash）"><a href="#脚本哈希支付P2SH（Pay-to-Script-Hash）" class="headerlink" title="脚本哈希支付P2SH（Pay to Script Hash）"></a>脚本哈希支付P2SH（Pay to Script Hash）</h2><p>一开始以为这个和Multiple Signatures是一样的东西，后来看了很多博客才知道是可以通过这种方法实现P2MS,P2SH是2012年提出的，个人理解这个脚本是为了防止Script过于长而导致交易失败，通过HASH160得到脚本的哈希值，这样就能解决长度问题</p>
<hr>
<p>P2SH中的脚本包括三部分，赎回脚本(redeem Script)、锁定脚本（locking Script）、解锁脚本（unlocking Script）</p>
<hr>
<p>赎回脚本(redeem Script)类似于之前脚本里的锁定脚本（locking Script）内容是一致的<br>锁定脚本（locking Script）形式是固定的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本（unlocking Script）与赎回脚本相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">&lt;Sig&gt;</span><br><span class="line">···       #需要的签名以及其他内容</span><br><span class="line">&lt;serialized redeem Script&gt; #序列化的赎回脚本，作为数据而不作为脚本语言压栈</span><br></pre></td></tr></table></figure>
<p>脚本的执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先就是解锁的脚本压栈</span><br><span class="line">此时栈顶就是&lt;serialized redeem Script&gt;</span><br><span class="line">然后锁定脚本依次压栈</span><br><span class="line">先得到赎回栈顶的哈希值</span><br><span class="line">再与锁定脚本中的哈希值对比两者不匹配验证就失败</span><br><span class="line">成功则序列化脚本会被反序列化再与栈内的剩余内容（也就是解锁脚本中剩下的所有&lt;Sig&gt;或者其他内容）构成完整的脚本</span><br></pre></td></tr></table></figure>

<p>下面以实现P2PKH与P2MS两种脚本为例写两个P2SH脚本</p>
<hr>
<h3 id="P2PKH"><a href="#P2PKH" class="headerlink" title="P2PKH"></a>P2PKH</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DUP</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;address&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Sig&gt;</span><br><span class="line">&lt;Pubkey&gt;</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   </span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="P2MS"><a href="#P2MS" class="headerlink" title="P2MS"></a>P2MS</h3><p>赎回脚本(redeem Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_M</span><br><span class="line">&lt;PublicKey 1&gt;</span><br><span class="line">&lt;PublicKey 2&gt; </span><br><span class="line">... </span><br><span class="line">&lt;PublicKey N&gt; </span><br><span class="line">OP_N </span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>锁定脚本（locking Script）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;   #redeem Script的哈希</span><br><span class="line">OP_EQUAL</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解锁脚本(unlocking Script)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          # N个人中随意M个人的签名</span><br><span class="line">&lt;serialized redeem Script&gt;</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0            </span><br><span class="line">&lt;Sig1&gt;</span><br><span class="line">&lt;Sig2&gt;</span><br><span class="line">...</span><br><span class="line">&lt;SigM&gt;          </span><br><span class="line">&lt;serialized redeem Script&gt;</span><br><span class="line">----------</span><br><span class="line">OP_HASH160</span><br><span class="line">&lt;redeem Script hash&gt;  </span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h2 id="作业中的unknown脚本（P2PK-P2MS）"><a href="#作业中的unknown脚本（P2PK-P2MS）" class="headerlink" title="作业中的unknown脚本（P2PK+P2MS）"></a>作业中的unknown脚本（P2PK+P2MS）</h2><h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><ul>
<li>生成一个涉及四方的多签名交易，这样交易可以由第一方（银行）与另外三方（客户）中的任何一方（客户）共同赎回，而不仅仅只是客户或银行。对于这个问题，你可以假设是银行的角色，这样银行的私钥就是你的私钥，而银行的公钥就是你的公钥。使用keygen.py生成客户密钥并将它们粘贴到ex2a.py中。</li>
<li>赎回事务并确保scriptPubKey尽可能小。可以使用任何合法的签名组合来赎回交易，但要确保所有组合都有效</li>
</ul>
<hr>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>该交易中一共有四位参与者，银行与三位客户，需要银行与其他任何一个用户的签名才能赎回交易，如果只用多重签名，那么不需要银行的签名也能赎回，所以我们要把实验分两步，一步是验证银行签名，另外一步是验证客户签名。所以可以用P2PK+P2MS构成的脚本</p>
<h3 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h3><p>其实上述两个步骤没有先后顺序，银行和客户身份先验证后验证都无所谓，反正逃不过验证，只不过用的脚本会不一样</p>
<h4 id="先银行后客户"><a href="#先银行后客户" class="headerlink" title="先银行后客户"></a>先银行后客户</h4><p>锁定脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;pubkey bank&gt;     #银行公钥</span><br><span class="line">OP_CHECKSIGVERIFY #使用OP_CHECKSIGVERIFY而不用OP_CHECKSIG是因为它不会有在栈里压数剧，后面脚本执行不会出错</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        #三个客户的公钥</span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>解锁脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0             </span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt;       #注意顺序，因为先验证银行，所以银行的pubkey要在栈顶</span><br></pre></td></tr></table></figure>
<p>完整脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">&lt;sig bank&gt; </span><br><span class="line">----------</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIGVERIFY</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIG</span><br></pre></td></tr></table></figure>
<p>执行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL	| 起始状态</span><br><span class="line">0           | OP_0压栈</span><br><span class="line">0&lt;sig cust&gt;	| &lt;sig cust&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;	| &lt;sig bank&gt;压栈</span><br><span class="line">0&lt;sig cust&gt;&lt;sig bank&gt;&lt;pubkey bank&gt;	| pubkey bank压栈</span><br><span class="line">0&lt;sig cust&gt;	| CHECKSIGVERIFY验证&lt;sig bank&gt;和&lt;pubkey bank&gt;是否匹配并将它们pop掉，匹配则继续，不匹配直接就验证不成功</span><br><span class="line">0&lt;sig cust&gt; 1	| OP_1压栈，确定需要检查的参数</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt;	| 3个pubkey压栈</span><br><span class="line">0&lt;sig cust&gt; 1 &lt;pubkey 1&gt;&lt;pubkey 2&gt;&lt;pubkey 3&gt; 3  | OP_3确定3个参数作为检查的范围</span><br><span class="line">true	| OP_CHECKMULTISIG检查多重签名，成功返回一个ture，否则验证失败</span><br></pre></td></tr></table></figure>
<h4 id="先客户后银行"><a href="#先客户后银行" class="headerlink" title="先客户后银行"></a>先客户后银行</h4><p>原理相同只给出完整脚本（注意脚本指令变了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig bank&gt; </span><br><span class="line">OP_0</span><br><span class="line">&lt;sig cust&gt;</span><br><span class="line">----------</span><br><span class="line">OP_1</span><br><span class="line">&lt;pubkey 1&gt;</span><br><span class="line">&lt;pubkey 2&gt;</span><br><span class="line">&lt;pubkey 3&gt;        </span><br><span class="line">OP_3</span><br><span class="line">OP_CHECKMULTISIGVERIFY</span><br><span class="line">&lt;pubkey bank&gt;     </span><br><span class="line">OP_CHECKSIG</span><br></pre></td></tr></table></figure>

<h1 id="自定义的脚本（解方程？？？）"><a href="#自定义的脚本（解方程？？？）" class="headerlink" title="自定义的脚本（解方程？？？）"></a>自定义的脚本（解方程？？？）</h1><h2 id="作业要求-1"><a href="#作业要求-1" class="headerlink" title="作业要求"></a>作业要求</h2><p>(a）生成可通过以下两个线性方程组的解x，y）赎回的交易:<br>x+y= (StudentID of First Half）和x-y= (StudentID of Second Half)<br>[为确保存在整数解，请更改右侧两个数字的最后一位，使数字都是偶数或都是奇数]。<br>(b）赎回交易。赎回脚本应尽可能小。也就是说，一个有效的<code>scriptSig</code>应该是简单地将两个整数x和y发送到堆栈中。确保在<code>scriptPubKey</code>中使用了<code>OP_ADD</code>和<code>OP_SUB</code>。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>这个作业看起来就像是让你解个方程，然后验证一下你解的方乘对不对。（不过要是真的用这样脚本交易比特币那自己币子不是别人想用就随便用了嘛ORZ）<br>已经说了解锁脚本就是x和y，那么首先压入栈里的就是x和y，那接下就要验证x和y是不是方乘的解。<br>首先先把xy复制一遍，因为需要验证两个方程得用两边，就用到了<code>OP_2DUP</code>，它的定义是这样的，所以能把栈顶两个元素赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_2DUP:</span><br><span class="line">check_args(2)</span><br><span class="line">v1 &#x3D; stack[-2]</span><br><span class="line">v2 &#x3D; stack[-1]</span><br><span class="line">stack.append(v1)</span><br><span class="line">stack.append(v2)</span><br></pre></td></tr></table></figure>
<p>然后就把x和y加起来，用<code>OP_ADD</code>脚本，它在执行的时候会把x和y<code>pop</code>掉然后再把结果<code>push</code>进栈里<br>接着拿这个<code>result</code>和原方程里的值比较是否一致，这里之所以使用的是<code>OP_EQUALVERIFY</code>，是因为它不会产生一个返回值，而使用<code>OP_EQUAL</code>会在栈里留下一个ture值没法处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUALVERIFY:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack[-1]</span><br><span class="line">                v2 &#x3D; stack[-2]</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                    stack.pop()</span><br></pre></td></tr></table></figure>
<p>然后差不多和前面一样的思路，先得到一个减的结果，然后和方程里的值比较，用<code>OP_EQUAL</code>验证，在栈里留下一个true值,这里可以看到并不是直接返回一个false或者true，而是返回的<code>\x01</code>或者<code> </code>，应该是和true或者false一样的功能，为空是false，不为空是ture</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif sop &#x3D;&#x3D; OP_EQUAL:</span><br><span class="line">                check_args(2)</span><br><span class="line">                v1 &#x3D; stack.pop()</span><br><span class="line">                v2 &#x3D; stack.pop()</span><br><span class="line"></span><br><span class="line">                if v1 &#x3D;&#x3D; v2:</span><br><span class="line">                    stack.append(b&quot;\x01&quot;)</span><br><span class="line">                else:</span><br><span class="line">                    stack.append(b&quot;&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="实现脚本"><a href="#实现脚本" class="headerlink" title="实现脚本"></a>实现脚本</h2><h3 id="锁定脚本"><a href="#锁定脚本" class="headerlink" title="锁定脚本"></a>锁定脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<h3 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;X&gt; #解方程的得到的xy值</span><br><span class="line">&lt;y&gt;</span><br></pre></td></tr></table></figure>
<h3 id="脚本运行过程"><a href="#脚本运行过程" class="headerlink" title="脚本运行过程"></a>脚本运行过程</h3><p>完整的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;X&gt; </span><br><span class="line">&lt;y&gt;</span><br><span class="line">-----</span><br><span class="line">OP_2DUP</span><br><span class="line">OP_ADD</span><br><span class="line">&lt;StudentID of First Half&gt;</span><br><span class="line">OP_EQUALVERIFY</span><br><span class="line">OP_SUB</span><br><span class="line">&lt;StudentID of Second Half&gt;</span><br><span class="line">OP_EQUAL</span><br></pre></td></tr></table></figure>
<p>运行过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL    #起始状态，栈内为空</span><br><span class="line">&lt;x&gt;     #x压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #y压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;x&gt;&lt;y&gt; #OP_2DUP复制栈顶及栈顶下一个元素并压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt; #OP_ADD弹出xy并且将xy相加的结果压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;&lt;add_result&gt;&lt;stuid first&gt; #学号前四位压栈</span><br><span class="line">&lt;x&gt;&lt;y&gt;  #OP_EQUALVERIFY验证两个内容是否相等，相等则将其弹出</span><br><span class="line">&lt;sub_result&gt; #OP_SUB弹出xy并且将xy相减的结果压栈</span><br><span class="line">&lt;sub_result&gt;&lt;stuid second&gt; #学号后三位压栈</span><br><span class="line">ture    #OP_EQUAL验证栈内的两个数值是否相等然后将true压栈</span><br></pre></td></tr></table></figure>
<h2 id="掉进去的坑"><a href="#掉进去的坑" class="headerlink" title="掉进去的坑"></a>掉进去的坑</h2><p>没有用<code>OP_EQUALVERIFY</code>和<code>OP_EQUAL</code>用了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code><br>翻看python-bitcoinlib的源码，一开始只看到了<code>OP_NUMEQUALVERIFY</code>和<code>OP_NUMEQUAL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUAL:</span><br><span class="line">   bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.pop()</span><br><span class="line">   stack.append(bitcoin.core._bignum.bn2vch(bn))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elif opcode &#x3D;&#x3D; OP_NUMEQUALVERIFY:</span><br><span class="line">        bn &#x3D; long(bn1 &#x3D;&#x3D; bn2)</span><br><span class="line">        if not bn:</span><br><span class="line">            err_raiser(VerifyOpFailedError, opcode)</span><br><span class="line">        else:</span><br><span class="line">            # No exception, so time to pop the stack</span><br><span class="line">            stack.pop()</span><br><span class="line">            stack.pop()</span><br><span class="line">            return</span><br></pre></td></tr></table></figure>
<p>看似是没有什么大问题的，不过<code>OP_NUMEQUAL</code>里并没有直接把<code>bn</code>压栈，反而是调用了一个函数<code>bitcoin.core._bignum.bn2vch</code>，里面有<code>bignum</code>而且<code>bn</code>类型为<code>long</code>，调用的函数可能对bn做了处理导致最后没有办法得到ture之类的，那个函数也看了下定义之类的没有看得很清楚，因为函数里又调了别的函数。不过肯定是那个函数的锅。（浪费了我一份币子，还好当时分了十份）</p>
<h1 id="跨链原子交易"><a href="#跨链原子交易" class="headerlink" title="跨链原子交易"></a>跨链原子交易</h1><h2 id="实验介绍与要求"><a href="#实验介绍与要求" class="headerlink" title="实验介绍与要求"></a>实验介绍与要求</h2><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><blockquote>
<p>在本次任务中，你需要创建一个称为跨链原子交换的交易，允许两个实体在不同的区块链上安全地交换加密货币的所有权。</p>
</blockquote>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>在这项作业中，你需要实现Alice和Bob两方之间跨链原子交换代码的关键部分。Alice在BTCTestnet3上有比特币，这是project1使用的标准比特币测试网。Bob在BCY Testnet 上拥有比特币，BCY Testnet是Blockcypher 的比特币测试网，由Blockcypher独家挖矿和维护。他们希望安全地交换各自coin的所有权，这是一个简单交易无法完成的事情，因为它们位于不同的区块链上。这里的想法是围绕一个只有一方(Alice）知道的秘密x建立交易。在这些事务中，只有H(x)将被发布，而x为秘密。交易将以这样的方式建立，一旦x被揭露，双方都可以赎回对方发送的硬币。如果x永远不会被揭露，双方将能够安全地取回他们的原始硬币，而不需要另一方的帮助。这种方法也适用于其他加密货币。</p>
</blockquote>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><blockquote>
<p>运行课程代码pip install -r requirements.txt安装所需的依赖项。确保使用的是python3。</p>
</blockquote>
<p>这个之前已经已经接安装过了这次就不用再做了</p>
<h3 id="创建BTC密钥并领取测试币"><a href="#创建BTC密钥并领取测试币" class="headerlink" title="创建BTC密钥并领取测试币"></a>创建BTC密钥并领取测试币</h3><blockquote>
<p>(a）为Alice和 Bob 创建BTC testnet密钥。你可以用keygen.py 生成密钥，把它填入keys.py中合适的地方。<br>(b）在 Project1中相同的<a href="https://coinfaucet.eu/en/btc-testnet/">coinfaucet</a> 上，为Alice的BTC地址领取测试币。</p>
</blockquote>
<p>这个也是之前做过的了，慢慢找公交车人行道自行车吧，Good Luck！</p>
<h3 id="注册BCY创建密钥领取测试币"><a href="#注册BCY创建密钥领取测试币" class="headerlink" title="注册BCY创建密钥领取测试币"></a>注册BCY创建密钥领取测试币</h3><blockquote>
</blockquote>
<p>(a）在Blockcypher注册帐户以获取API token: <a href="https://accounts.blockcypher.com/%E3%80%82">https://accounts.blockcypher.com/。</a><br>(b）为Alice和Bob创建BCY testnet密钥并填入keys.py.<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl-X POST https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;addrs?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure><br>(c）在Blockcypher 测试网（BCY）上为Bob的BCY地址领取测试币。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl-d&#39;&#123;&quot;address&quot;:&quot;BOB_BCY_ADDRESs&quot;, &quot;amount&quot;: 1000000&#125;&#39; https:&#x2F;&#x2F;api.blockcypher.com&#x2F;v1&#x2F;bcy&#x2F;test&#x2F;faucet?token&#x3D;YOURTOKEN</span><br></pre></td></tr></table></figure>

<p>这个相对于BTC领币过程也太“流云行水”了，curl用前需要装一下，终端输入<code>sudo apt-get install curl</code>就能装了。然后在终端里输入题目里给的命令就好</p>
<h3 id="划分测试币"><a href="#划分测试币" class="headerlink" title="划分测试币"></a>划分测试币</h3><blockquote>
<p>使用split_test_coins.py（填写文件中的相关字段）划分领取的币。</p>
</blockquote>
<p>把对应的地方填上就行，不过需要注意，划分BCY测试币的时候，注意改一下调用的函数（参考keys.py中的样式），以及network的类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#BTC：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;)</span><br><span class="line">#BCY：</span><br><span class="line">my_private_key &#x3D; CBitcoinSecret.from_secret_bytes(x(&#39;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#39;))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="完善swap-py"><a href="#完善swap-py" class="headerlink" title="完善swap.py"></a>完善swap.py</h3><blockquote>
<p>填写swap.py.</p>
</blockquote>
<p>按照提示一步一步写</p>
<h3 id="完善swap-scripts-py"><a href="#完善swap-scripts-py" class="headerlink" title="完善swap_scripts.py"></a>完善swap_scripts.py</h3><p>这部分是本次实验核心部分</p>
<h3 id="要求及源码"><a href="#要求及源码" class="headerlink" title="要求及源码"></a>要求及源码</h3><blockquote>
<p>A.考虑创建跨链原子交换所需事务所需的ScriptPubKey。此交易必须可由接收者赎回（如果他们有一个与Hash(x）对应的秘密x)，或者可以用发送者和接收者的两个签名赎回。完善swap_scripts.py 中的脚本coinExchangeScript。<br>B.完善脚本:<br>(a）在接收者知道秘密x的情况下，编写赎回交易所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig1.<br>(b）在发送方和接收方都签署事务的情况下，编写赎回事务所需的ScriptSig。在swap_scripts.py中完善coinExchangeScriptSig2.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScript</span>(<span class="params">public_key_sender, public_key_recipient, hash_of_secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig1</span>(<span class="params">sig_recipient, secret</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinExchangeScriptSig2</span>(<span class="params">sig_sender, sig_recipient</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="comment"># fill this in!</span></span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据题目要求，我们的锁定脚本应该能够用两个不同解锁脚本解锁所以需要用到<code>OP_IF</code>、<code>OP_ELSE</code> 、<code>OP_ENDIF</code>等脚本语言来处理不同解锁脚本。</p>
<ul>
<li>对于用秘密X及接收者签名赎回的脚本，我们只需要先验证X的哈希值是否正确，然后再用P2PK脚本验证接收者签名</li>
<li>对于用两个签名赎回的脚本，我们只需要用P2MS就可以实现</li>
<li>对于知道秘密X的解锁脚本，我们只需将签名与秘密依次压栈</li>
<li>对于两个签名的解锁脚本，把两个签名压栈即可，不过需要注意先OP_0</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="解锁脚本1："><a href="#解锁脚本1：" class="headerlink" title="解锁脚本1："></a>解锁脚本1：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sig_recipient&gt;,&lt;seret&gt;</span><br></pre></td></tr></table></figure>

<h5 id="解锁脚本2："><a href="#解锁脚本2：" class="headerlink" title="解锁脚本2："></a>解锁脚本2：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_0 &lt;sig_sender&gt; ,&lt;sig_recipient&gt;</span><br></pre></td></tr></table></figure>
<h5 id="锁定脚本："><a href="#锁定脚本：" class="headerlink" title="锁定脚本："></a>锁定脚本：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OP_DEPTH, 2, OP_EQUAL, </span><br><span class="line">OP_IF, </span><br><span class="line">OP_HASH160, hash_of_secret, OP_EQUALVERIFY, public_key_recipient, OP_CHECKSIG, OP_ELSE,</span><br><span class="line">2, public_key_sender, public_key_recipient, 2, OP_CHECKMULTISIG,</span><br><span class="line">OP_ENDIF</span><br></pre></td></tr></table></figure>
<h5 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h5><p>可以把锁定脚本看作三部分</p>
<ul>
<li>第一部分是用来检验是哪个解锁脚本从而执行相应的检验<br>我们可以发现两个脚本长度不同，于是可以利用这一点来分辨是哪个脚本，利用<code>OP_DEPTH</code>得到栈大小可以实现<br>或者是在第二个解锁脚本中存在一个OP_O，于是可以用<code>OP_PICK</code>将栈底复制到栈顶，然后与<code>OP_0</code>对比，这样也可以</li>
<li>第二部分是执行<code>OP_IF</code>后的分支，验证秘密X与接收者签名</li>
<li>第三部分是执行<code>OP_ELSE</code>后的分至，验证两个签名</li>
</ul>
<h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NULL							|初始状态栈为空</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |&lt;sig_recipient&gt;,&lt;seret&gt;依次入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;	   |OP_DEPTH得到栈大小为2，并将2压栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;2&gt;&lt;2&gt;	|2入栈</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;&lt;Ture&gt;	|OP_EQUAL比较栈顶两个的值并将其pop，将Ture压栈，这里不能用OP_EQUALVERIFY，因为我们需要在栈里压入一个标志来确定执行OP_IF还是OP_ELSE</span><br><span class="line">&lt;sig_recipient&gt;&lt;seret&gt;		  |OP_IF检测栈顶值并将其pop，进入if分支</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;|得到secret的哈希值</span><br><span class="line">&lt;sig_recipient&gt;&lt;hash_of_secret?&gt;&lt;hash_of_secret&gt;|&lt;hash_of_secret&gt;压栈</span><br><span class="line">&lt;sig_recipient&gt;		   	  |OP_EQUALVERIFY检测两个哈希值是否相等并将其pop</span><br><span class="line">&lt;sig_recipient&gt;&lt;public_key_recipient&gt;|public_key_recipient入栈</span><br><span class="line">&lt;Ture&gt;						  |OP_CHECKSIG</span><br><span class="line">&lt;Ture&gt;						  |最后几步其实就是简单的P2PK，最后的OP_ENDIF一定要加			</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于解锁脚本1+锁定脚本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">NULL 							           |初始状态栈为空</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;       |&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;依次入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;    |OP_DEPTH得到栈大小为，并将3压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;3&gt;&lt;2&gt; |2入栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;&lt;False&gt;|OP_EQUAL比较栈顶两个的值并将其pop，将False压栈</span><br><span class="line">&lt;OP_0&gt;&lt;sig_recipient&gt;&lt;sig_recipient&gt;	   |OP_IF检测栈顶值，为false，不执行if分至，有OP_ELSE，跳转到else</span><br><span class="line"></span><br><span class="line">#略</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>苏明yyds</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建（Windows）</title>
    <url>/2020/11/04/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>突然就想要有一个自己的博客，契机是NKU丨🐏开始在CSDN上发自己做过的东西，再加上之前在大二偶然发现的南开的学姐的博客上学到了好多东西，便开始着手搭建自己的博客，共费时两个晚上方有了简陋的博客。以下大概记录下建立博客的过程以及踩过的坑。</p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>注册账号之类就不赘述了，新建一个<code>Repository</code>，名字必须是<code>yourusername.github.io</code>，比如我的就是<code>YozoOba.github.io</code>，选择public，其他可以跳过直接创建就好了。</p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>直接从官网下载<a href="https://nodejs.org/zh-cn/">node.js</a>,一路默认设置+next安装完成，安装地址可以改一下。<br>安装完成后便可以使用npm了，注意不是nmp（我用的时候一直报错，直到百度搜索的时候它提示我是不是要搜索“npm”才意识到，orz）<br>打开cmd输入<code>node -v</code>可以查看node.js版本来确认是否安装完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\14616&gt;node -v</span><br><span class="line">v14.15.0</span><br></pre></td></tr></table></figure>
<p>这样就算安装成功了</p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>同样直接官网下载<a href="https://git-scm.com/download/win">Git</a>，安装完成之后设置环境变量（一般安装的时候都会自动设置的，如果安装后没法使用Git可以考虑是不是没有设置环境变量）</p>
<p>下载完成后随意一个地方点右键可以打开<code>Git Bash</code>，先配置你的用户信息，在里面输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>然后再生成ssh密钥，这一步的目的是为设置Github密钥，这样就不用每次推送都输入密码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;你的GitHub邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>然后三个回车，找到生成的<code>.ssh</code>文件夹，一般存放在<code>C\users</code>目录下，复制id_rsa.pub中的密钥。</p>
<p>也可以直接右键打开Git Gui，点击左上角<code>Help</code>中的<code>Show SSH Key </code>按照提示生成ssh密钥， 同样三个回车，它会直接显示出密钥直接复制，不需要再去文件里复制</p>
<p>接下来打开Github，在<code>Setting</code>里找到<code>SSH and GPG keys</code>新建SSH，复制你本地生成的<code>public key</code>进去，然后保存，它会让你输入Github密码，然后就成功了。</p>
<p>在Git Bash中输入ssh <a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>来验证是否成功，第一次验证的话会让你输入一个yes，显示successfully便成功了，but后面的语句不需要看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>hexo是通过npm命令安装的<br>首先建立一个hexo文件夹，放在你喜欢的位置，在该文件夹打开cmd或者power shell，不过推荐Git Bash，我用前两个的时候总莫名奇妙报错，用了Git Bash就顺畅许多嘿嘿。<br>安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<h1 id="本地建立博客"><a href="#本地建立博客" class="headerlink" title="本地建立博客"></a>本地建立博客</h1><p>在hexo文件夹下打开Git Bash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init blog&#x2F;&#x2F;blog是项目的名字，你可以叫别的或者省略</span><br><span class="line">cd blog</span><br><span class="line">hexo g&#x2F;&#x2F;编译</span><br><span class="line">hexo s&#x2F;&#x2F;s就是server，执行完就可以通过4000端口预览网站</span><br></pre></td></tr></table></figure>
<p>在浏览器输入<code>localhost：4000</code>便可以看到一个页面，这是默认的landscape主题<br>#将博客部署到Github<br>这里我们之前在Github上配置的仓库就有了用处，首先打开blog文件夹里的_config.yml文件进行配置，找到最下方的deploy进行配置，repo后面是你对应的仓库地址，由于已经设置过ssh，所以不需要写成https之类格式。<br>注意：<strong>冒号之后一定要有一个空格，不然会报错！冒号之后一定要有一个空格，不然会报错！冒号之后一定要有一个空格，不然会报错！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:yourname&#x2F;yourname.github.io.git&#x2F;&#x2F;填充上yourname即可</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>然后安装hexo的插件，在Git Hash里输入命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完成后输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>其中<code>hexo d</code>就是将你网站部署到GitHub上的命令，完成后再访问<code>https://yourname.github.io/</code>便会惊奇的发现你能通过互联网访问到了！！！</p>
<h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><p>我用的是Ayer主题，作者的使用文档真的写的太太太详细了，设置主题这一部分基本没什么难度，直接参考<a href="https://shen-yu.gitee.io/2019/ayer/">Ayer</a><br>按照作者的嘱咐安装好各种插件，修改好配置文件记得加空格就没多大问题。</p>
<h1 id="博客使用"><a href="#博客使用" class="headerlink" title="博客使用"></a>博客使用</h1><p>其实执行到上一步之后我是一脸懵逼的，我究竟该怎么使用这个博客呢，为啥侧边栏就只有一个主页和一个归档能点其他都是404？？？<br>然后就去翻了好久hexo的官方文档，并且又去找了好多博客看，最后终于发现了是因为没有建立对应的page<br>按照<a href="https://shen-yu.gitee.io/2019/ayer/">Ayer</a>的提示，然后打开终端（记得要在blog文件夹打开，不然无论你输入什么都是报错）<br>首先输入以下创建分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后将以下内容复制到/source/categories/index.md 文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">layout: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后输入以下创建标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样需要配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">layout: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>友链、关于之类的，配置同以</p>
<p>面对着空空如也的博客，我又开始迷茫了，那标签分类这些东西该怎么生成呢，又是翻了好多博客，终于有一个博主醍醐灌顶地说了一局，标签分类是不能独立存在的，必须依赖于博文存在<br>于是输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &lt;hello world&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到在blog\source_posts目录下出现了我们刚才创建的文档在配置中输入相关的tags和categories然后保存，注意<strong>冒号后面要有空格不然又会报错！！！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hello world</span><br><span class="line">tags: yourtags</span><br><span class="line">categories: yourcategories</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>然后在终端中输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>等到命令执行完，我们再访问博客，便会发现已经有了相对应的标签和分类，至此，博客初步搭建完成，<em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p>
<h1 id="搭建过程中报错及解决办法"><a href="#搭建过程中报错及解决办法" class="headerlink" title="搭建过程中报错及解决办法"></a>搭建过程中报错及解决办法</h1><h2 id="关于副标题不显示的问题"><a href="#关于副标题不显示的问题" class="headerlink" title="关于副标题不显示的问题"></a>关于副标题不显示的问题</h2><p>在markdown中“#”与“##”之类的后面要先加一个空格在输入内容，否则可能不被认为是标题之类的而显示成##xxx之类的奇怪的东西</p>
<h2 id="nmp不是内部命令，也不是可运行的程序"><a href="#nmp不是内部命令，也不是可运行的程序" class="headerlink" title="nmp不是内部命令，也不是可运行的程序"></a>nmp不是内部命令，也不是可运行的程序</h2><p>orz这个是因为把npm敲成了nmp哈哈哈。</p>
<h2 id="git不是内部或外部命令-也不是可运行的程序"><a href="#git不是内部或外部命令-也不是可运行的程序" class="headerlink" title="git不是内部或外部命令,也不是可运行的程序"></a>git不是内部或外部命令,也不是可运行的程序</h2><p>这个可能是因为没有安装Git或者没有在系统变量里配置Git</p>
<h2 id="hexo-无法加载文件-因为在此系统上禁止运行脚本。"><a href="#hexo-无法加载文件-因为在此系统上禁止运行脚本。" class="headerlink" title="hexo : 无法加载文件 ,因为在此系统上禁止运行脚本。"></a>hexo : 无法加载文件 ,因为在此系统上禁止运行脚本。</h2><p>以管理员身份打开cmd或者power shell，输入<code>set-executionpolicy remotesighed</code>选择是即可解决</p>
<h2 id="hexo报错Usage-hexo"><a href="#hexo报错Usage-hexo" class="headerlink" title="hexo报错Usage: hexo "></a>hexo报错Usage: hexo <command></h2><p>这个前面提到过，是因为没有在blog文件下打开终端，只需要cd 到你创建的blog之类的文件夹就行了</p>
<h2 id="can-not-read-an-implicit-mapping-pair-a-colon-is-missed-at-line-109-column"><a href="#can-not-read-an-implicit-mapping-pair-a-colon-is-missed-at-line-109-column" class="headerlink" title="can not read an implicit mapping pair; a colon is missed at line 109, column"></a>can not read an implicit mapping pair; a colon is missed at line 109, column</h2><p>这个是前面提到的空格问题，在它报错的地方加上应该有点空格就好</p>
<h2 id="fatal-protocol-‘github-https’-is-not-supported"><a href="#fatal-protocol-‘github-https’-is-not-supported" class="headerlink" title="fatal: protocol ‘github:https’ is not supported"></a>fatal: protocol ‘github:https’ is not supported</h2><p>貌似还是因为空格问题，然后顺便把https样式的url改成了带@的那个</p>
<h2 id="Could-not-resolve-hostname-github-Name-or-service-not-known"><a href="#Could-not-resolve-hostname-github-Name-or-service-not-known" class="headerlink" title="Could not resolve hostname github: Name or service not known"></a>Could not resolve hostname github: Name or service not known</h2><p>这个我记得我是用了Git Bash就好了</p>
<h2 id="Spawn-failed"><a href="#Spawn-failed" class="headerlink" title="Spawn failed"></a>Spawn failed</h2><p>这个把博客文档里的.git删除掉，然后再在删除的地方输入以下命令新建一个仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<h2 id="not-a-git-repository-or-any-of-the-parent-directories"><a href="#not-a-git-repository-or-any-of-the-parent-directories" class="headerlink" title="not a git repository (or any of the parent directories)"></a>not a git repository (or any of the parent directories)</h2><p>这个是因为上面那个错误把.git删了没有新建，<code>git init</code><br>之后就好了</p>
<h2 id="err-YAMLException-can-not-read-a-block-mapping-entry"><a href="#err-YAMLException-can-not-read-a-block-mapping-entry" class="headerlink" title="err: YAMLException: can not read a block mapping entry"></a>err: YAMLException: can not read a block mapping entry</h2><p>还是空格问题，找到应该加空格的地方加空格就好了</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web25</title>
    <url>/2021/04/26/Bugku-Web25/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web-25"><a href="#Bugku-Web-25" class="headerlink" title="Bugku Web 25"></a>Bugku Web 25</h1><blockquote>
<p>提示是SQL约束攻击</p>
</blockquote>
<h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>&emsp;&emsp;进入场景，看到是一个web管理系统，需要登陆，旁边可以看到注册的通道，先随意注册一个账号<br><img src="https://i.loli.net/2021/04/26/T3y4NEZFHDtqQ8a.png" alt="1.png"><br><img src="https://i.loli.net/2021/04/26/Itpq6YvGl3Z4OP2.png" alt="2.jpg"><br><img src="https://i.loli.net/2021/04/26/xUlTGruCJoZKLm9.png" alt="3.png"></p>
<p>&emsp;&emsp;推测只有管理员账户才会显示出flag，利用SQL约束攻击，SQL语句会将查询的字段后的空格格式化，随意我们注册的用户名为<code>admin </code>，此时再登录就可以得到flag<br><img src="https://i.loli.net/2021/04/26/iIjEn9GfueochHr.png" alt="4.png"></p>
<h2 id="SQL约束攻击"><a href="#SQL约束攻击" class="headerlink" title="SQL约束攻击"></a>SQL约束攻击</h2><p>&emsp;&emsp;例如下面的代码中，输入的字符串末尾空格会被删除，<code>admin</code>与<code>admin     </code>是一样的,这是因为在“字符串比较”期间，SQL会在内部使用空格来填充字符串，以便在比较之前使其它们的长度保持一致。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = mysql_real_escape_string($_GET[&#x27;username&#x27;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&#x27;password&#x27;]);</span><br><span class="line">$query = &quot;<span class="keyword">SELECT</span> *</span><br><span class="line">          <span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line">          <span class="keyword">WHERE</span> username=<span class="string">&#x27;$username&#x27;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">$res = mysql_query($query, $database);</span></span><br><span class="line"><span class="string">if($res) &#123;</span></span><br><span class="line"><span class="string">  if(mysql_num_rows($res) &gt; 0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;</span></span><br><span class="line"><span class="string">    $query = &quot;</span><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(username, <span class="keyword">password</span>)</span><br><span class="line">              <span class="keyword">VALUES</span> (<span class="string">&#x27;$username&#x27;</span>,<span class="string">&#x27;$password&#x27;</span>)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 当注册时，后台一般先select一下用户名看看是否存在，然后再insert</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$username = mysql_real_escape_string($_GET[&#x27;username&#x27;]);</span><br><span class="line">$password = mysql_real_escape_string($_GET[&#x27;password&#x27;]);</span><br><span class="line">$query = &quot;<span class="keyword">SELECT</span> *</span><br><span class="line">          <span class="keyword">FROM</span> <span class="keyword">users</span></span><br><span class="line">          <span class="keyword">WHERE</span> username=<span class="string">&#x27;$username&#x27;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string">$res = mysql_query($query, $database);</span></span><br><span class="line"><span class="string">if($res) &#123;</span></span><br><span class="line"><span class="string">  if(mysql_num_rows($res) &gt; 0) &#123;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  else &#123;</span></span><br><span class="line"><span class="string">    $query = &quot;</span><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">users</span>(username, <span class="keyword">password</span>)</span><br><span class="line">              <span class="keyword">VALUES</span> (<span class="string">&#x27;$username&#x27;</span>,<span class="string">&#x27;$password&#x27;</span>)<span class="string">&quot;;</span></span><br></pre></td></tr></table></figure>
<p>这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。</p>
<p>    主要原理就是<code>insert</code>时候有<code>varchar(n)</code>的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将<code>admin+[大量空格]</code>删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入<code>admin+[空格]（截取）</code>和自定义密码了。</p>
<p>    如果使用用户名<code>“vampire”</code>和密码“<code>random_pass</code>”登录的话，对比时是<code>admin</code>与<code>admin+[大量空格]</code>，会将前面的<code>admin</code>添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?</p>
<p>    当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的<code>return $username</code>，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。</p>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Bugku Web26</title>
    <url>/2021/04/26/Bugku-Web26/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Bugku-Web26"><a href="#Bugku-Web26" class="headerlink" title="Bugku Web26"></a>Bugku Web26</h1><blockquote>
<p>Google</p>
</blockquote>
<p>进入场景，只有一行小字</p>
<blockquote>
<p>are you from google<br>推测应该将Referer改为谷歌的网址<br>用hackbar或者burpsuite都可以做到<br><img src="https://i.loli.net/2021/04/26/csMgnaRJ1Vr5OSz.png" alt="1.png"><br><img src="https://i.loli.net/2021/04/26/pPDgWoYyNB9vtjk.png" alt="2.png"></p>
</blockquote>
]]></content>
      <tags>
        <tag>Bugku Web</tag>
      </tags>
  </entry>
</search>
